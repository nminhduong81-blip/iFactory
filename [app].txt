[app]
profile=Equipment Realtime Visualization
refresh_fast_ms=3000
refresh_slow_ms=5000

[ui]
theme=light
layout_path=e_ui/assets/layout/layout.json

[db]
mssql_host=10.148.144.71
mssql_port=1433
mssql_db=yntti
mssql_user=sa
mssql_password=123456
mssql_auth=sql

from __future__ import annotations
import configparser
import asyncio
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from threading import Lock, Timer
from typing import Callable, List, Optional
import os
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class Theme(str, Enum):
    DARK = "dark"
    LIGHT = "light"

@dataclass(frozen=True, slots=True)
class AppConfig:
    profile: str
    refresh_fast_ms: int
    refresh_slow_ms: int
    theme: Theme
    layout_path: str
    base_dir: Path
    mssql_host: Optional[str]
    mssql_port: int
    mssql_db: Optional[str]
    mssql_user: Optional[str]
    mssql_password: Optional[str]
    mssql_auth: str

class _ConfigReloader(FileSystemEventHandler):
    def __init__(self, cfg_file: Path, debounce_sec: float = 0.3):
        super().__init__()
        self.cfg_file = cfg_file
        self._config: Optional[AppConfig] = None
        self._lock = Lock()
        self._observer = Observer()
        self._observer.schedule(self, str(cfg_file.parent), recursive=False)
        self._observer.start()
        self._debounce_timer: Optional[Timer] = None
        self._debounce_sec = debounce_sec
        self._callbacks: List[Callable[[AppConfig], None]] = []
        self._load()

    def on_modified(self, event):
        self._maybe_reload(event)

    def on_created(self, event):
        self._maybe_reload(event)

    def on_moved(self, event):
        self._maybe_reload(event)

    def _maybe_reload(self, event):
        try:
            p = Path(str(getattr(event, "src_path", "")))
        except Exception:
            return
        if p == self.cfg_file:
            if self._debounce_timer and self._debounce_timer.is_alive():
                self._debounce_timer.cancel()
            self._debounce_timer = Timer(self._debounce_sec, self._load)
            self._debounce_timer.start()

    def _load(self):
        parser = configparser.ConfigParser(interpolation=None)
        if self.cfg_file.exists():
            parser.read(self.cfg_file, encoding="utf-8")
        else:
            parser["app"] = {
                "profile": "Equipment Realtime Visualization",
                "refresh_fast_ms": "100",
                "refresh_slow_ms": "1000",
            }
            parser["ui"] = {"theme": "dark", "layout_path": "e_ui/assets/layout/layout.json"}
            parser["db"] = {
                "mssql_host": "",
                "mssql_port": "1433",
                "mssql_db": "",
                "mssql_user": "",
                "mssql_password": "",
                "mssql_auth": "sql",
            }
            self.cfg_file.parent.mkdir(parents=True, exist_ok=True)
            with self.cfg_file.open("w", encoding="utf-8") as f:
                parser.write(f)

        def get_or(section: str, option: str, fallback: str) -> str:
            try:
                return parser.get(section, option, fallback=fallback).strip()
            except Exception:
                return fallback

        base = Path.cwd()
        profile = get_or("app", "profile", "Equipment Realtime Visualization")
        refresh_fast_ms = int(get_or("app", "refresh_fast_ms", "100"))
        refresh_slow_ms = int(get_or("app", "refresh_slow_ms", "1000"))
        theme_raw = get_or("ui", "theme", "dark").lower()
        layout_path = get_or("ui", "layout_path", "e_ui/assets/layout/layout.json")
        theme = Theme.DARK if theme_raw == "dark" else Theme.LIGHT

        mssql_host = os.getenv("MSSQL_HOST") or get_or("db", "mssql_host", "") or None
        mssql_port_raw = os.getenv("MSSQL_PORT") or get_or("db", "mssql_port", "1433")
        mssql_port = int(mssql_port_raw) if mssql_port_raw else 1433
        mssql_db = os.getenv("MSSQL_DB") or get_or("db", "mssql_db", "") or None
        mssql_user = os.getenv("MSSQL_USER") or get_or("db", "mssql_user", "") or None
        mssql_password = os.getenv("MSSQL_PASSWORD") or get_or("db", "mssql_password", "") or None
        mssql_auth = (os.getenv("MSSQL_AUTH") or get_or("db", "mssql_auth", "sql")).lower()

        cfg = AppConfig(
            profile=profile,
            refresh_fast_ms=refresh_fast_ms,
            refresh_slow_ms=refresh_slow_ms,
            theme=theme,
            layout_path=layout_path,
            base_dir=base,
            mssql_host=mssql_host.strip() if mssql_host else None,
            mssql_port=mssql_port,
            mssql_db=mssql_db.strip() if mssql_db else None,
            mssql_user=mssql_user.strip() if mssql_user else None,
            mssql_password=mssql_password.strip() if mssql_password else None,
            mssql_auth=mssql_auth.strip(),
        )
        with self._lock:
            self._config = cfg
            callbacks = list(self._callbacks)
        for fn in callbacks:
            try:
                try:
                    loop = asyncio.get_running_loop()
                except RuntimeError:
                    loop = None
                if loop and loop.is_running():
                    loop.call_soon_threadsafe(fn, cfg)
                else:
                    fn(cfg)
            except Exception:
                pass

    def get_config(self) -> AppConfig:
        with self._lock:
            assert self._config is not None
            return self._config

    def register_callback(self, func: Callable[[AppConfig], None]) -> None:
        with self._lock:
            self._callbacks.append(func)

    def shutdown(self) -> None:
        try:
            self._observer.stop()
            self._observer.join(timeout=1.0)
        except Exception:
            pass

_cfg_reloader: Optional[_ConfigReloader] = None

def init_config_system() -> None:
    global _cfg_reloader
    if _cfg_reloader is None:
        base = Path.cwd()
        cfg_file = base / "a_core/configs/app.ini"
        cfg_file.parent.mkdir(parents=True, exist_ok=True)
        _cfg_reloader = _ConfigReloader(cfg_file)

def get_config() -> AppConfig:
    if _cfg_reloader is None:
        init_config_system()
    assert _cfg_reloader is not None
    return _cfg_reloader.get_config()

def register_config_callback(func: Callable[[AppConfig], None]) -> None:
    if _cfg_reloader is None:
        init_config_system()
    assert _cfg_reloader is not None
    _cfg_reloader.register_callback(func)

def shutdown_config_system() -> None:
    global _cfg_reloader
    if _cfg_reloader is not None:
        _cfg_reloader.shutdown()
        _cfg_reloader = None

# path: b_infrastructure/database/models/models_cold.py
from __future__ import annotations
from datetime import datetime
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import String, DateTime, Integer, UniqueConstraint
from b_infrastructure.database.base import ColdBase

class StatusHistory(ColdBase):
    __tablename__ = "history_status"
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    equip_code: Mapped[str] = mapped_column(String(30), index=True)
    equip_status: Mapped[str] = mapped_column(String(5), nullable=False)
    create_date: Mapped[datetime] = mapped_column(DateTime, nullable=False, index=True)
    __table_args__ = (UniqueConstraint("equip_code", "create_date", name="uix_status_history"),)

class InputHistory(ColdBase):
    __tablename__ = "history_input"
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    equip_code: Mapped[str] = mapped_column(String(30), index=True)
    material_batch: Mapped[str] = mapped_column(String(100), nullable=False)
    feeding_time: Mapped[datetime] = mapped_column(DateTime, nullable=False)
    create_date: Mapped[datetime] = mapped_column(DateTime, nullable=False, index=True)
    end_time: Mapped[datetime | None] = mapped_column(DateTime, nullable=True)
    __table_args__ = (UniqueConstraint("equip_code", "feeding_time", name="uix_input_history"),)

class StatusPeriod(ColdBase):
    __tablename__ = "history_status_period"
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    equip_code: Mapped[str] = mapped_column(String(30), index=True)
    equip_status: Mapped[str] = mapped_column(String(5), nullable=False)
    end_time: Mapped[datetime] = mapped_column(DateTime, nullable=False, index=True)
    __table_args__ = (UniqueConstraint("equip_code", "end_time", name="uix_status_period"),)

class InputPeriod(ColdBase):
    __tablename__ = "history_input_period"
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    equip_code: Mapped[str] = mapped_column(String(30), index=True)
    material_batch: Mapped[str] = mapped_column(String(100), nullable=False)
    feeding_time: Mapped[datetime] = mapped_column(DateTime, nullable=False)
    create_date: Mapped[datetime] = mapped_column(DateTime, nullable=False, index=True)
    __table_args__ = (UniqueConstraint("equip_code", "feeding_time", name="uix_input_period"),)

# path: b_infrastructure/database/models/models_hot.py
from __future__ import annotations
from datetime import datetime
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy import String, DateTime, CHAR, CheckConstraint, Index, Integer
from b_infrastructure.database.base import HotBase

class LatestStatus(HotBase):
    __tablename__ = "latest_status"
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    equip_code: Mapped[str] = mapped_column(String(30), unique=True, index=True)
    equip_status: Mapped[str] = mapped_column(CHAR(1), nullable=False)
    last_update: Mapped[datetime] = mapped_column(DateTime, nullable=False, index=True)
    __table_args__ = (Index("ix_latest_status", "equip_code", "last_update"),)

class LatestInput(HotBase):
    __tablename__ = "latest_input"
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    equip_code: Mapped[str] = mapped_column(String(30), unique=True, index=True)
    material_batch: Mapped[str] = mapped_column(String(30), nullable=False)
    feeding_time: Mapped[datetime] = mapped_column(DateTime, nullable=False, index=True)
    __table_args__ = (Index("ix_latest_input", "material_batch", "feeding_time"),)

from __future__ import annotations
from sqlalchemy.orm import DeclarativeBase

class HotBase(DeclarativeBase):
    pass

class ColdBase(DeclarativeBase):
    pass

__all__ = ["HotBase", "ColdBase"]

from __future__ import annotations
import asyncio
import functools
import os
import importlib.util
from abc import ABC, abstractmethod
from contextlib import asynccontextmanager
from dataclasses import dataclass
from pathlib import Path
from typing import Optional, AsyncGenerator, Literal, Union, Dict, Any, List, Callable, Iterable
from concurrent.futures import ThreadPoolExecutor
from urllib.parse import quote_plus
import pandas as pd
from sqlalchemy import create_engine, text, event
from sqlalchemy.engine import Engine
from sqlalchemy.ext.asyncio import create_async_engine, AsyncEngine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import sessionmaker, Session
from tenacity import retry, stop_after_attempt, wait_fixed
from b_infrastructure.database.base import HotBase, ColdBase

ToSqlMethod = Union[Literal["multi"], None, Callable[[Any, Any, List[str], Iterable[tuple[Any, ...]]], Optional[int]]]

@dataclass
class DBConfig:
    echo: bool = False
    cache_size: int = -262144
    mmap_size: int = 2147483648
    pool_size: int = 20
    max_overflow: int = 40
    pool_timeout: int = 30
    pool_recycle: int = 1800
    pool_use_lifo: bool = True
    dtype_backend: Union[Literal["pyarrow"], Literal["numpy_nullable"]] = "pyarrow"
    sqlite_isolation: Literal["DEFERRED", "IMMEDIATE", "EXCLUSIVE"] = "IMMEDIATE"
    sqlite_bulk_synchronous: Union[Literal["OFF"], Literal["NORMAL"]] = "OFF"
    sqlite_bulk_locking: Union[Literal["NORMAL"], Literal["EXCLUSIVE"]] = "EXCLUSIVE"
    sqlite_page_size: int = 32768
    sqlite_threads: int = max(2, (os.cpu_count() or 4))
    mssql_mars: bool = False
    mssql_encrypt: bool = True
    mssql_trust_server_certificate: bool = True
    mssql_multi_subnet_failover: bool = True
    mssql_application_intent: Literal["ReadWrite", "ReadOnly"] = "ReadWrite"
    mssql_connect_timeout: int = 15
    mssql_fast_executemany: bool = True
    mssql_odbc_pooling: bool = False

@dataclass
class RemoteDBParams:
    host: Optional[str] = None
    port: Optional[int] = 1433
    database: Optional[str] = None
    user: Optional[str] = None
    password: Optional[str] = None
    auth: Literal["sql"] = "sql"

class BaseDBManager(ABC):
    @abstractmethod
    async def connect(self) -> None: ...
    @abstractmethod
    async def dispose(self) -> None: ...

def _listen_sqlite_pragmas(engine: Engine, pragmas: Dict[str, Any]) -> None:
    @event.listens_for(engine, "connect")
    def _on_connect(dbapi_conn, rec):
        c = dbapi_conn.cursor()
        for k, v in pragmas.items():
            c.execute(f"PRAGMA {k}={v}")
        c.close()

def _listen_mssql_session(engine: Engine) -> None:
    @event.listens_for(engine, "connect")
    def _on_connect(dbapi_conn, rec):
        cur = dbapi_conn.cursor()
        cur.execute("SET NOCOUNT ON")
        cur.execute("SET XACT_ABORT ON")
        cur.execute("SET LOCK_TIMEOUT 30000")
        cur.execute("SET ARITHABORT ON")
        cur.execute("SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED")
        cur.close()

class AsyncSQLiteManager(BaseDBManager):
    def __init__(self, db_file: Path, base, config: DBConfig):
        self.db_file = db_file
        self.db_file.parent.mkdir(parents=True, exist_ok=True)
        self.base = base
        self.config = config
        self.engine_write: AsyncEngine = create_async_engine(
            f"sqlite+aiosqlite:///{db_file}",
            echo=config.echo,
            future=True,
            connect_args={"timeout": 60, "isolation_level": config.sqlite_isolation},
            pool_pre_ping=True,
            pool_use_lifo=config.pool_use_lifo,
        )
        self.engine_read: AsyncEngine = create_async_engine(
            f"sqlite+aiosqlite:///{db_file}",
            echo=config.echo,
            future=True,
            connect_args={"timeout": 60, "isolation_level": "DEFERRED"},
            pool_pre_ping=True,
            pool_use_lifo=config.pool_use_lifo,
        )
        _listen_sqlite_pragmas(self.engine_write.sync_engine, {
            "journal_mode": "WAL",
            "synchronous": "NORMAL",
            "temp_store": "MEMORY",
            "cache_size": self.config.cache_size,
            "mmap_size": self.config.mmap_size,
            "wal_autocheckpoint": 100000,
            "foreign_keys": "ON",
            "journal_size_limit": 1073741824,
            "automatic_index": "ON",
            "busy_timeout": 15000,
            "cache_spill": "OFF",
            "locking_mode": "NORMAL",
            "query_only": 0,
            "threads": self.config.sqlite_threads,
        })
        _listen_sqlite_pragmas(self.engine_read.sync_engine, {
            "synchronous": "NORMAL",
            "temp_store": "MEMORY",
            "cache_size": self.config.cache_size,
            "mmap_size": self.config.mmap_size,
            "wal_autocheckpoint": 100000,
            "foreign_keys": "ON",
            "journal_size_limit": 1073741824,
            "automatic_index": "ON",
            "busy_timeout": 15000,
            "cache_spill": "OFF",
            "locking_mode": "NORMAL",
            "query_only": 1,
            "read_uncommitted": 1,
            "threads": self.config.sqlite_threads,
        })
        self.session_factory_write = async_sessionmaker(self.engine_write, expire_on_commit=False)
        self.session_factory_read = async_sessionmaker(self.engine_read, expire_on_commit=False)
        self.sync_engine_write = create_engine(
            f"sqlite:///{db_file}",
            echo=config.echo,
            future=True,
            connect_args={"check_same_thread": False, "timeout": 60, "isolation_level": config.sqlite_isolation},
            pool_pre_ping=True,
            pool_use_lifo=config.pool_use_lifo,
        )
        self.sync_engine_read = create_engine(
            f"sqlite:///{db_file}",
            echo=config.echo,
            future=True,
            connect_args={"check_same_thread": False, "timeout": 60, "isolation_level": "DEFERRED"},
            pool_pre_ping=True,
            pool_use_lifo=config.pool_use_lifo,
        )
        _listen_sqlite_pragmas(self.sync_engine_write, {
            "journal_mode": "WAL",
            "synchronous": "NORMAL",
            "temp_store": "MEMORY",
            "cache_size": self.config.cache_size,
            "mmap_size": self.config.mmap_size,
            "wal_autocheckpoint": 100000,
            "foreign_keys": "ON",
            "journal_size_limit": 1073741824,
            "automatic_index": "ON",
            "busy_timeout": 15000,
            "cache_spill": "OFF",
            "locking_mode": "NORMAL",
            "query_only": 0,
            "threads": self.config.sqlite_threads,
        })
        _listen_sqlite_pragmas(self.sync_engine_read, {
            "journal_mode": "WAL",
            "synchronous": "NORMAL",
            "temp_store": "MEMORY",
            "cache_size": self.config.cache_size,
            "mmap_size": self.config.mmap_size,
            "wal_autocheckpoint": 100000,
            "foreign_keys": "ON",
            "journal_size_limit": 1073741824,
            "automatic_index": "ON",
            "busy_timeout": 15000,
            "cache_spill": "OFF",
            "locking_mode": "NORMAL",
            "query_only": 1,
            "read_uncommitted": 1,
            "threads": self.config.sqlite_threads,
        })
        workers = min(32, max(4, (os.cpu_count() or 4) * 4))
        self._executor: ThreadPoolExecutor = ThreadPoolExecutor(max_workers=workers, thread_name_prefix="sqlite")

    @property
    def engine(self) -> AsyncEngine:
        return self.engine_write

    @property
    def sync_engine(self) -> Engine:
        return self.sync_engine_write

    def _run(self, fn, *args, **kwargs):
        loop = asyncio.get_running_loop()
        return loop.run_in_executor(self._executor, functools.partial(fn, *args, **kwargs))

    async def connect(self) -> None:
        is_new = not self.db_file.exists() or self.db_file.stat().st_size == 0
        async with self.engine_write.begin() as conn:
            if is_new:
                await conn.execute(text(f"PRAGMA page_size={self.config.sqlite_page_size}"))
            await conn.execute(text("PRAGMA optimize"))
            await conn.run_sync(self.base.metadata.create_all)
        async with self.engine_read.begin() as conn:
            pass
        def _apply():
            size = self.db_file.stat().st_size if self.db_file.exists() else 0
            mmap = min(self.config.mmap_size, max(self.config.sqlite_page_size, size + 536870912))
            with self.sync_engine_write.begin() as conn:
                conn.execute(text(f"PRAGMA mmap_size={mmap}"))
                conn.execute(text("PRAGMA optimize"))
            with self.sync_engine_read.begin() as conn:
                conn.execute(text(f"PRAGMA mmap_size={mmap}"))
        await self._run(_apply)

    @asynccontextmanager
    async def session(self) -> AsyncGenerator[AsyncSession, None]:
        async with self.session_factory_write() as s:
            try:
                yield s
                await s.commit()
            except Exception:
                await s.rollback()
                raise

    @asynccontextmanager
    async def session_read(self) -> AsyncGenerator[AsyncSession, None]:
        async with self.session_factory_read() as s:
            try:
                yield s
            finally:
                ...

    async def execute(self, sql: str, params: Optional[Dict[str, Any]] = None) -> None:
        def _exec():
            with self.sync_engine_write.begin() as conn:
                conn.execute(text(sql), params or {})
        await self._run(_exec)

    async def read_df(self, query: str, params: Optional[Dict[str, Any]] = None) -> pd.DataFrame:
        def _read():
            with self.sync_engine_read.connect() as conn:
                return pd.read_sql(text(query), conn, params=params, dtype_backend=self.config.dtype_backend)
        df = await self._run(_read)
        return df.convert_dtypes()

    async def read_df_chunks(self, query: str, params: Optional[Dict[str, Any]] = None, chunksize: int = 100000) -> Iterable[pd.DataFrame]:
        def _gen():
            with self.sync_engine_read.connect() as conn:
                it = pd.read_sql(text(query), conn, params=params, dtype_backend=self.config.dtype_backend, chunksize=chunksize)
                for chunk in it:
                    yield chunk.convert_dtypes()
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(self._executor, lambda: _gen())

    async def to_sql(self, table: str, df: pd.DataFrame, if_exists: Literal["fail", "replace", "append"] = "append", index: bool = False, chunksize: int = 100000, method: ToSqlMethod = "multi") -> None:
        if df is None or df.empty:
            return
        def _write():
            with self.sync_engine_write.begin() as conn:
                conn.execute(text(f"PRAGMA synchronous={self.config.sqlite_bulk_synchronous}"))
                conn.execute(text("PRAGMA temp_store=MEMORY"))
                conn.execute(text(f"PRAGMA locking_mode={self.config.sqlite_bulk_locking}"))
                df.to_sql(table, conn, if_exists=if_exists, index=index, chunksize=chunksize, method=method)
        await self._run(_write)

    async def dispose(self) -> None:
        async with self.engine_write.begin() as conn:
            await conn.execute(text("PRAGMA wal_checkpoint(TRUNCATE)"))
        await self.engine_write.dispose()
        await self.engine_read.dispose()
        self.sync_engine_write.dispose()
        self.sync_engine_read.dispose()
        self._executor.shutdown(wait=True)

class MSSQLManager(BaseDBManager):
    def __init__(self, config: DBConfig, remote: RemoteDBParams):
        self.config = config
        self.remote = remote
        self._engine: Optional[Engine] = None
        self.session_factory: Optional[sessionmaker] = None
        self._executor: Optional[ThreadPoolExecutor] = None

    @property
    def engine(self) -> Engine:
        if not self._engine:
            raise RuntimeError("MSSQL engine not initialized")
        return self._engine

    def _run(self, fn, *args, **kwargs):
        loop = asyncio.get_running_loop()
        return loop.run_in_executor(self._executor, functools.partial(fn, *args, **kwargs))

    def _build_engine_pyodbc(self) -> Optional[Engine]:
        if importlib.util.find_spec("pyodbc") is None:
            return None
        import pyodbc
        pyodbc.pooling = self.config.mssql_odbc_pooling
        driver = "ODBC Driver 18 for SQL Server"
        server = (self.remote.host or "").strip()
        port = self.remote.port or 1433
        database = (self.remote.database or "master").strip()
        user = (self.remote.user or "").strip()
        pwd = (self.remote.password or "").strip()
        mars = "Yes" if self.config.mssql_mars else "No"
        encrypt = "Yes" if self.config.mssql_encrypt else "No"
        tsc = "Yes" if self.config.mssql_trust_server_certificate else "No"
        msf = "Yes" if self.config.mssql_multi_subnet_failover else "No"
        app_intent = self.config.mssql_application_intent
        timeout = self.config.mssql_connect_timeout
        conn_str = (
            f"DRIVER={{{driver}}};"
            f"SERVER={server},{port};"
            f"DATABASE={database};"
            f"UID={user};PWD={pwd};"
            f"MARS Connection={mars};"
            f"TrustServerCertificate={tsc};"
            f"Encrypt={encrypt};"
            f"MultiSubnetFailover={msf};"
            f"Application Intent={app_intent};"
            f"Connect Timeout={timeout};"
        )
        u = quote_plus(conn_str)
        return create_engine(
            f"mssql+pyodbc:///?odbc_connect={u}",
            echo=self.config.echo,
            future=True,
            pool_size=self.config.pool_size,
            max_overflow=self.config.max_overflow,
            pool_timeout=self.config.pool_timeout,
            pool_recycle=self.config.pool_recycle,
            pool_pre_ping=True,
            pool_reset_on_return="rollback",
            pool_use_lifo=self.config.pool_use_lifo,
            fast_executemany=self.config.mssql_fast_executemany,
        )

    def _build_engine_pytds_sql(self) -> Engine:
        import pytds
        def creator():
            return pytds.connect(
                self.remote.host or "",
                self.remote.database or "master",
                self.remote.user or "",
                self.remote.password or "",
                port=self.remote.port or 1433,
                use_mars=self.config.mssql_mars,
            )
        return create_engine(
            "mssql+pytds://",
            echo=self.config.echo,
            future=True,
            pool_size=self.config.pool_size,
            max_overflow=self.config.max_overflow,
            pool_timeout=self.config.pool_timeout,
            pool_recycle=self.config.pool_recycle,
            pool_pre_ping=True,
            pool_reset_on_return="rollback",
            pool_use_lifo=self.config.pool_use_lifo,
            creator=creator,
        )

    def _build_engine(self) -> Engine:
        eng = self._build_engine_pyodbc()
        if eng is not None:
            return eng
        return self._build_engine_pytds_sql()

    @retry(stop=stop_after_attempt(3), wait=wait_fixed(2))
    async def connect(self) -> None:
        engine = self._build_engine()
        _listen_mssql_session(engine)
        def _test():
            with engine.connect() as conn:
                conn.execute(text("SELECT 1"))
        await asyncio.get_running_loop().run_in_executor(None, _test)
        self._engine = engine
        self.session_factory = sessionmaker(bind=engine, expire_on_commit=False)
        workers = min(128, max(16, (os.cpu_count() or 4) * 4, self.config.pool_size + self.config.max_overflow + 16))
        self._executor = ThreadPoolExecutor(max_workers=workers, thread_name_prefix="mssql")

    @asynccontextmanager
    async def session(self) -> AsyncGenerator[Session, None]:
        if not self.session_factory:
            raise RuntimeError("MSSQL session factory not initialized")
        s = self.session_factory()
        try:
            yield s
            s.commit()
        except Exception:
            s.rollback()
            raise
        finally:
            s.close()

    async def execute(self, sql: str, params: Optional[Dict[str, Any]] = None) -> None:
        def _exec():
            with self.engine.begin() as conn:
                conn.execute(text(sql), params or {})
        await self._run(_exec)

    async def fetch_df(self, query: str, params: Optional[Dict[str, Any]] = None) -> pd.DataFrame:
        def _fetch():
            with self.engine.connect() as conn:
                return pd.read_sql(text(query), conn, params=params, dtype_backend=self.config.dtype_backend)
        df = await self._run(_fetch)
        return df.convert_dtypes()

    async def fetch_df_stream(self, query: str, params: Optional[Dict[str, Any]] = None, chunksize: int = 200000) -> Iterable[pd.DataFrame]:
        def _gen():
            with self.engine.connect() as conn:
                it = pd.read_sql(text(query), conn, params=params, dtype_backend=self.config.dtype_backend, chunksize=chunksize)
                for chunk in it:
                    yield chunk.convert_dtypes()
        loop = asyncio.get_running_loop()
        return await loop.run_in_executor(self._executor, lambda: _gen())

    async def execute_many(self, statements: List[tuple[str, Optional[Dict[str, Any]]]], parallel: int = 8) -> None:
        sem = asyncio.Semaphore(parallel)
        async def _task(sql: str, p: Optional[Dict[str, Any]]):
            async with sem:
                await self.execute(sql, p)
        await asyncio.gather(*(_task(s, p) for s, p in statements))

    async def fetch_df_many(self, queries: List[tuple[str, Optional[Dict[str, Any]]]], parallel: int = 8) -> List[pd.DataFrame]:
        sem = asyncio.Semaphore(parallel)
        async def _task(q: str, p: Optional[Dict[str, Any]]):
            async with sem:
                return await self.fetch_df(q, p)
        return await asyncio.gather(*(_task(q, p) for q, p in queries))

    async def dispose(self) -> None:
        if self._engine:
            self._engine.dispose()
            self._engine = None
        if self._executor:
            self._executor.shutdown(wait=True)
            self._executor = None

class DatabaseOrchestrator:
    def __init__(self, base_dir: Path, remote: RemoteDBParams, config: DBConfig = DBConfig()):
        self.config = config
        self._hot = AsyncSQLiteManager(base_dir / "storage_data/hot_store.db", HotBase, config)
        self._cold = AsyncSQLiteManager(base_dir / "storage_data/cold_store.db", ColdBase, config)
        self._mssql = MSSQLManager(config, remote)
        self.managers: List[BaseDBManager] = [self._hot, self._cold, self._mssql]
        self._disposed = False
        self._drainer = None

    @property
    def hot(self) -> AsyncSQLiteManager:
        return self._hot

    @property
    def cold(self) -> AsyncSQLiteManager:
        return self._cold

    @property
    def mssql(self) -> MSSQLManager:
        return self._mssql

    async def initialize(self):
        await asyncio.gather(*(m.connect() for m in self.managers))
        from b_infrastructure.repositories.outbox import OutboxRepo
        await OutboxRepo(self._hot.engine).initialize()

    async def start_outbox_drainer(self, batch: int = 2000, interval: float = 0.2):
        if self._drainer:
            return
        from b_infrastructure.repositories.outbox import OutboxDrainer
        d = OutboxDrainer(self, batch=batch, interval=interval)
        await d.start()
        self._drainer = d

    async def stop_outbox_drainer(self):
        if self._drainer:
            await self._drainer.stop()
            self._drainer = None

    async def dispose_all(self):
        if self._disposed:
            return
        self._disposed = True
        await self.stop_outbox_drainer()
        await asyncio.gather(*(m.dispose() for m in self.managers))

    async def healthcheck(self) -> Dict[str, bool]:
        results: Dict[str, bool] = {}
        try:
            async with self.hot.engine.begin() as conn:
                await conn.execute(text("SELECT 1"))
            results["SQLiteHot"] = True
        except Exception:
            results["SQLiteHot"] = False
        try:
            async with self.cold.engine.begin() as conn:
                await conn.execute(text("SELECT 1"))
            results["SQLiteCold"] = True
        except Exception:
            results["SQLiteCold"] = False
        try:
            eng = self._mssql._engine
            if eng is not None:
                def _ping(engine: Engine) -> None:
                    with engine.connect() as conn:
                        conn.execute(text("SELECT 1"))
                await asyncio.get_running_loop().run_in_executor(None, _ping, eng)
                results["MSSQL"] = True
            else:
                results["MSSQL"] = False
        except Exception:
            results["MSSQL"] = False
        return results

from __future__ import annotations
import asyncio
from datetime import datetime
from typing import Any, AsyncGenerator, Dict, List
from sqlalchemy import bindparam, text
from sqlalchemy.engine import Engine
from b_infrastructure.utils.time import to_local_naive
from b_infrastructure.database.manager import DatabaseOrchestrator
from b_infrastructure.utils.threads import AsyncIterFromThread

SQL_MSSQL_LATEST_INPUT = text("""
WITH latest AS (
    SELECT EQUIP_CODE, MATERIAL_BATCH, FEED_TIME, ROW_NUMBER() OVER (PARTITION BY EQUIP_CODE ORDER BY FEED_TIME DESC) rn
    FROM yntti.dbo.RPT_FEEDING_DETAIL
    WHERE EQUIP_CODE IN :codes
)
SELECT EQUIP_CODE, MATERIAL_BATCH, FEED_TIME FROM latest WHERE rn=1
""").bindparams(bindparam("codes", expanding=True))

SQL_MSSQL_INPUT_PERIOD = text("""
SELECT EQUIP_CODE, MATERIAL_BATCH, FEED_TIME
FROM yntti.dbo.RPT_FEEDING_DETAIL
WHERE EQUIP_CODE IN :codes AND FEED_TIME BETWEEN :start AND :end
ORDER BY FEED_TIME ASC
""").bindparams(bindparam("codes", expanding=True))

def _engine(db: DatabaseOrchestrator) -> Engine:
    return db.mssql.engine

async def fetch_latest_input(db: DatabaseOrchestrator, codes: List[str]) -> List[Dict[str, Any]]:
    codes = sorted({str(c) for c in codes if c})
    if not codes:
        return []
    eng = _engine(db)
    def _exec() -> List[Dict[str, Any]]:
        with eng.connect() as conn:
            res = conn.execution_options(stream_results=True).execute(SQL_MSSQL_LATEST_INPUT, {"codes": codes})
            out: List[Dict[str, Any]] = []
            append = out.append
            for r in res:
                ft = r[2]
                if not ft:
                    continue
                append({"equip_code": str(r[0]), "material_batch": r[1], "feeding_time": to_local_naive(ft)})
            return out
    return await asyncio.to_thread(_exec)

async def stream_input_period(db: DatabaseOrchestrator, codes: List[str], start: datetime, end: datetime, chunk: int = 5000) -> AsyncGenerator[List[Dict[str, Any]], None]:
    eng = _engine(db)
    codes = sorted({str(c) for c in codes if c})
    if not codes:
        if False:
            yield []
        return
    def _iter():
        with eng.connect() as conn:
            res = conn.execution_options(stream_results=True).execute(SQL_MSSQL_INPUT_PERIOD, {"codes": codes, "start": start, "end": end})
            batch: List[Dict[str, Any]] = []
            append = batch.append
            for row in res:
                ft = row[2]
                if ft:
                    append({"equip_code": str(row[0]), "material_batch": row[1], "feeding_time": to_local_naive(ft)})
                    if len(batch) >= chunk:
                        yield batch
                        batch = []
                        append = batch.append
            if batch:
                yield batch
    async for b in AsyncIterFromThread(_iter()):
        yield b

from __future__ import annotations
import asyncio
from datetime import datetime
from typing import Any, AsyncGenerator, Dict, List
from sqlalchemy import bindparam, text
from sqlalchemy.engine import Engine
from b_infrastructure.utils.time import to_local_naive
from b_infrastructure.database.manager import DatabaseOrchestrator
from b_infrastructure.utils.threads import AsyncIterFromThread

SQL_MSSQL_LATEST_STATUS = text("""
WITH latest AS (
    SELECT EQUIP_CODE, EQUIP_STATUS, START_TIME,
           ROW_NUMBER() OVER (PARTITION BY EQUIP_CODE ORDER BY START_TIME DESC) rn
    FROM TT_EQ_STATUS
    WHERE EQUIP_CODE IN :codes
)
SELECT EQUIP_CODE, EQUIP_STATUS, START_TIME AS EVENT_TIME
FROM latest WHERE rn=1
""").bindparams(bindparam("codes", expanding=True))

SQL_MSSQL_STATUS_PERIOD = text("""
SELECT EQUIP_CODE, EQUIP_STATUS, START_TIME
FROM TT_EQ_STATUS
WHERE EQUIP_CODE IN :codes AND (
    (START_TIME BETWEEN :start AND :end)
    OR (END_TIME BETWEEN :start AND :end)
    OR (START_TIME < :start AND (END_TIME IS NULL OR END_TIME >= :start))
)
ORDER BY START_TIME ASC
""").bindparams(bindparam("codes", expanding=True))

def _engine(db: DatabaseOrchestrator) -> Engine:
    return db.mssql.engine

async def fetch_latest_status(db: DatabaseOrchestrator, codes: List[str]) -> List[Dict[str, Any]]:
    codes = sorted({str(c) for c in codes if c})
    if not codes:
        return []
    eng = _engine(db)
    def _exec() -> List[Dict[str, Any]]:
        with eng.connect() as conn:
            res = conn.execution_options(stream_results=True).execute(SQL_MSSQL_LATEST_STATUS, {"codes": codes})
            out: List[Dict[str, Any]] = []
            append = out.append
            to_local = to_local_naive
            for r in res:
                ev = r[2]
                if ev:
                    append({"equip_code": str(r[0]), "equip_status": None if r[1] is None else str(r[1]), "event_time": to_local(ev)})
            return out
    return await asyncio.to_thread(_exec)

async def stream_status_period(db: DatabaseOrchestrator, codes: List[str], start: datetime, end: datetime, chunk: int = 5000) -> AsyncGenerator[List[Dict[str, Any]], None]:
    eng = _engine(db)
    codes = sorted({str(c) for c in codes if c})
    if not codes:
        if False:
            yield []
        return
    def _iter():
        with eng.connect() as conn:
            res = conn.execution_options(stream_results=True).execute(SQL_MSSQL_STATUS_PERIOD, {"codes": codes, "start": start, "end": end})
            batch: List[Dict[str, Any]] = []
            append = batch.append
            to_local = to_local_naive
            for row in res:
                ev = row[2]
                if ev:
                    append({"equip_code": str(row[0]), "equip_status": None if row[1] is None else str(row[1]), "event_time": to_local(ev)})
                    if len(batch) >= chunk:
                        yield batch
                        batch = []
                        append = batch.append
            if batch:
                yield batch
    async for b in AsyncIterFromThread(_iter()):
        yield b

from __future__ import annotations
import asyncio
from typing import List
from sqlalchemy import select
from sqlalchemy.dialects.sqlite import insert as sqlite_insert
from b_infrastructure.database.manager import DatabaseOrchestrator
from b_infrastructure.database.models.models_cold import InputHistory
from b_infrastructure.utils.sqlite import ensure_table_once
from b_infrastructure.utils.time import to_local_naive
from d_application.dto import InputEvent

class InputHistoryRepository:
    def __init__(self, db: DatabaseOrchestrator, batch: int = 2000) -> None:
        self.db = db
        self.batch = max(1, batch)
        self._init_done = False

    async def initialize(self) -> None:
        if not self._init_done:
            await ensure_table_once(self.db.cold.engine, InputHistory)
            self._init_done = True

    async def insert_events(self, events: List[InputEvent]) -> int:
        if not events:
            return 0
        def _run():
            total = 0
            with self.db.cold.sync_engine.begin() as conn:
                stmt = sqlite_insert(InputHistory).on_conflict_do_nothing(index_elements=["equip_code", "feeding_time"])
                for i in range(0, len(events), self.batch):
                    chunk = [{"equip_code": e["equip_code"], "material_batch": e["material_batch"], "feeding_time": to_local_naive(e["feeding_time"]), "create_date": to_local_naive(e["feeding_time"])} for e in events[i:i+self.batch]]
                    conn.execute(stmt, chunk)
                    total += len(chunk)
            return total
        return await asyncio.to_thread(_run)

    async def query_period(self, code: str, start, end) -> List[InputEvent]:
        def _read():
            with self.db.cold.sync_engine_read.connect() as conn:
                stmt = (
                    select(InputHistory.equip_code, InputHistory.material_batch, InputHistory.feeding_time)
                    .where(InputHistory.equip_code == code)
                    .where(InputHistory.feeding_time >= start)
                    .where(InputHistory.feeding_time <= end)
                    .order_by(InputHistory.feeding_time.desc())
                )
                return conn.execute(stmt).all()
        rows = await asyncio.to_thread(_read)
        return [{"equip_code": r[0], "material_batch": r[1], "feeding_time": to_local_naive(r[2])} for r in rows]

from __future__ import annotations
import asyncio
from datetime import datetime
from typing import List, Tuple, Dict, Any, cast
from sqlalchemy import select
from sqlalchemy.dialects.sqlite import insert as sqlite_insert
from b_infrastructure.database.manager import DatabaseOrchestrator
from b_infrastructure.database.models.models_cold import InputPeriod
from b_infrastructure.utils.sqlite import ensure_table_once
from b_infrastructure.utils.time import to_local_naive
from d_application.dto import InputEvent

class InputPeriodRepository:
    def __init__(self, db: DatabaseOrchestrator, batch: int = 2000) -> None:
        self.db = db
        self.batch = max(1, batch)
        self._init_done = False

    async def initialize(self) -> None:
        if not self._init_done:
            await ensure_table_once(self.db.cold.engine, InputPeriod)
            self._init_done = True

    async def insert_events(self, events: List[InputEvent]) -> int:
        if not events:
            return 0
        def _run():
            seen: set[Tuple[str, datetime]] = set()
            rows: List[Dict[str, Any]] = []
            for e in events:
                code = str(e["equip_code"])
                ft = to_local_naive(cast(datetime, e["feeding_time"]))
                if not code or not ft:
                    continue
                k = (code, ft)
                if k in seen:
                    continue
                seen.add(k)
                rows.append({"equip_code": code, "material_batch": e["material_batch"], "feeding_time": ft, "create_date": ft})
            if not rows:
                return 0
            total = 0
            with self.db.cold.sync_engine.begin() as conn:
                stmt = sqlite_insert(InputPeriod).on_conflict_do_nothing(index_elements=["equip_code", "feeding_time"])
                for i in range(0, len(rows), self.batch):
                    chunk = rows[i:i+self.batch]
                    conn.execute(stmt, chunk)
                    total += len(chunk)
            return total
        return await asyncio.to_thread(_run)

    async def query_period(self, codes: List[str], start: datetime, end: datetime) -> List[InputEvent]:
        if not codes:
            return []
        codes = list({str(c) for c in codes if c})
        def _chunks(xs: List[str], n: int):
            for i in range(0, len(xs), n):
                yield xs[i:i+n]
        def _read():
            out = []
            with self.db.cold.sync_engine_read.connect() as conn:
                for part in _chunks(codes, 800):
                    stmt = (
                        select(InputPeriod.equip_code, InputPeriod.material_batch, InputPeriod.feeding_time)
                        .where(InputPeriod.equip_code.in_(part))
                        .where(InputPeriod.feeding_time >= start)
                        .where(InputPeriod.feeding_time <= end)
                        .order_by(InputPeriod.feeding_time.desc())
                    )
                    out.extend(conn.execute(stmt).all())
            return out
        rows = await asyncio.to_thread(_read)
        items: List[InputEvent] = []
        for r in rows:
            items.append({"equip_code": str(r[0]), "material_batch": str(r[1]), "feeding_time": to_local_naive(cast(datetime, r[2]))})
        items.sort(key=lambda x: x["feeding_time"], reverse=True)
        return items

from __future__ import annotations
import asyncio
from typing import List
from sqlalchemy import select
from sqlalchemy.dialects.sqlite import insert as sqlite_insert
from b_infrastructure.database.manager import DatabaseOrchestrator
from b_infrastructure.database.models.models_cold import StatusHistory
from b_infrastructure.utils.sqlite import ensure_table_once
from b_infrastructure.utils.time import to_local_naive
from d_application.dto import StatusEvent

class StatusHistoryRepository:
    def __init__(self, db: DatabaseOrchestrator, batch: int = 2000) -> None:
        self.db = db
        self.batch = max(1, batch)
        self._init_done = False

    async def initialize(self) -> None:
        if not self._init_done:
            await ensure_table_once(self.db.cold.engine, StatusHistory)
            self._init_done = True

    async def insert_events(self, events: List[StatusEvent]) -> int:
        if not events:
            return 0
        def _run():
            total = 0
            with self.db.cold.sync_engine.begin() as conn:
                stmt = sqlite_insert(StatusHistory).on_conflict_do_nothing(index_elements=["equip_code", "create_date"])
                for i in range(0, len(events), self.batch):
                    chunk = [{"equip_code": e["equip_code"], "equip_status": e.get("equip_status"), "create_date": to_local_naive(e["event_time"])} for e in events[i:i+self.batch]]
                    conn.execute(stmt, chunk)
                    total += len(chunk)
            return total
        return await asyncio.to_thread(_run)

    async def query_period(self, code: str, start, end) -> List[StatusEvent]:
        def _read():
            with self.db.cold.sync_engine_read.connect() as conn:
                stmt = (
                    select(StatusHistory.equip_code, StatusHistory.equip_status, StatusHistory.create_date)
                    .where(StatusHistory.equip_code == code)
                    .where(StatusHistory.create_date >= start)
                    .where(StatusHistory.create_date <= end)
                    .order_by(StatusHistory.create_date.desc())
                )
                return conn.execute(stmt).all()
        rows = await asyncio.to_thread(_read)
        return [{"equip_code": r[0], "equip_status": r[1], "event_time": to_local_naive(r[2])} for r in rows]

from __future__ import annotations
import asyncio
from datetime import datetime
from typing import List, Tuple, Dict, Any, cast
from sqlalchemy import select, func
from sqlalchemy.dialects.sqlite import insert as sqlite_insert
from b_infrastructure.database.manager import DatabaseOrchestrator
from b_infrastructure.database.models.models_cold import StatusPeriod
from b_infrastructure.utils.sqlite import ensure_table_once
from b_infrastructure.utils.time import to_local_naive
from d_application.dto import StatusEvent

class StatusPeriodRepository:
    def __init__(self, db: DatabaseOrchestrator, batch: int = 2000) -> None:
        self.db = db
        self.batch = max(1, batch)
        self._init_done = False

    async def initialize(self) -> None:
        if not self._init_done:
            await ensure_table_once(self.db.cold.engine, StatusPeriod)
            self._init_done = True

    async def insert_events(self, events: List[StatusEvent]) -> int:
        if not events:
            return 0
        def _run():
            seen: set[Tuple[str, datetime]] = set()
            rows: List[Dict[str, Any]] = []
            for e in events:
                code = str(e["equip_code"])
                ts = cast(datetime, e["event_time"])
                if not code or not ts:
                    continue
                k = (code, ts)
                if k in seen:
                    continue
                seen.add(k)
                rows.append({"equip_code": code, "equip_status": e.get("equip_status"), "end_time": ts})
            if not rows:
                return 0
            total = 0
            with self.db.cold.sync_engine.begin() as conn:
                stmt = sqlite_insert(StatusPeriod).on_conflict_do_nothing(index_elements=["equip_code", "end_time"])
                for i in range(0, len(rows), self.batch):
                    chunk = rows[i:i+self.batch]
                    conn.execute(stmt, chunk)
                    total += len(chunk)
            return total
        return await asyncio.to_thread(_run)

    async def query_period(self, codes: List[str], start: datetime, end: datetime) -> List[StatusEvent]:
        if not codes:
            return []
        codes = list({str(c) for c in codes if c})
        def _chunks(xs: List[str], n: int):
            for i in range(0, len(xs), n):
                yield xs[i:i+n]
        def _read():
            out = []
            with self.db.cold.sync_engine_read.connect() as conn:
                for part in _chunks(codes, 800):
                    prev_sq = (
                        select(
                            StatusPeriod.equip_code.label("equip_code"),
                            StatusPeriod.equip_status.label("equip_status"),
                            StatusPeriod.end_time.label("event_time"),
                            func.row_number().over(
                                partition_by=StatusPeriod.equip_code,
                                order_by=StatusPeriod.end_time.desc(),
                            ).label("rn"),
                        )
                        .where(StatusPeriod.equip_code.in_(part))
                        .where(StatusPeriod.end_time < start)
                    ).subquery("prev")
                    prev_sel = select(prev_sq.c.equip_code, prev_sq.c.equip_status, prev_sq.c.event_time).where(prev_sq.c.rn == 1)
                    curr_sel = (
                        select(
                            StatusPeriod.equip_code.label("equip_code"),
                            StatusPeriod.equip_status.label("equip_status"),
                            StatusPeriod.end_time.label("event_time"),
                        )
                        .where(StatusPeriod.equip_code.in_(part))
                        .where(StatusPeriod.end_time >= start)
                        .where(StatusPeriod.end_time <= end)
                    )
                    union_sub = prev_sel.union_all(curr_sel).subquery("u")
                    stmt = select(union_sub.c.equip_code, union_sub.c.equip_status, union_sub.c.event_time).order_by(union_sub.c.event_time.asc())
                    out.extend(conn.execute(stmt).all())
            return out
        rows = await asyncio.to_thread(_read)
        items: List[StatusEvent] = []
        for r in rows:
            ev = r[2]
            if isinstance(ev, str):
                try:
                    ev = datetime.fromisoformat(ev)
                except Exception:
                    continue
            equip_code = str(r[0])
            equip_status = None if r[1] is None else str(r[1])
            event_time = to_local_naive(cast(datetime, ev))
            items.append(cast(StatusEvent, {"equip_code": equip_code, "equip_status": equip_status, "event_time": event_time}))
        return items

from __future__ import annotations
from typing import List, Optional, Dict
from sqlalchemy import select
from sqlalchemy.dialects.sqlite import insert as sqlite_insert
from b_infrastructure.database.manager import DatabaseOrchestrator
from b_infrastructure.database.models.models_hot import LatestInput
from b_infrastructure.utils.sqlite import ensure_table_once
from b_infrastructure.utils.time import to_local_naive
from d_application.dto import InputSnapshot

class InputSnapshotRepository:
    def __init__(self, db: DatabaseOrchestrator) -> None:
        self.db = db
        self._init_done = False

    async def initialize(self) -> None:
        if not self._init_done:
            await ensure_table_once(self.db.hot.engine, LatestInput)
            self._init_done = True

    async def upsert_many(self, items: List[InputSnapshot]) -> int:
        if not items:
            return 0
        uniq: Dict[str, InputSnapshot] = {}
        for it in items:
            code = it["equip_code"]
            if not code:
                continue
            uniq[code] = it
        payload = [{"equip_code": it["equip_code"], "material_batch": it["material_batch"], "feeding_time": to_local_naive(it["feeding_time"])} for it in uniq.values()]
        total = 0
        async with self.db.hot.session() as s:
            base = sqlite_insert(LatestInput)
            stmt = base.on_conflict_do_update(
                index_elements=[LatestInput.equip_code],
                set_={"material_batch": base.excluded.material_batch, "feeding_time": base.excluded.feeding_time},
                where=base.excluded.feeding_time > LatestInput.feeding_time
            )
            for i in range(0, len(payload), 1000):
                chunk = payload[i:i+1000]
                await s.execute(stmt, chunk)
                total += len(chunk)
        return total

    async def fetch_all(self, codes: Optional[List[str]] = None) -> List[InputSnapshot]:
        async with self.db.hot.session_read() as s:
            q = select(LatestInput)
            if codes:
                q = q.where(LatestInput.equip_code.in_(list({str(c) for c in codes if c})))
            res = await s.execute(q)
            rows = res.scalars().all()
        return [{"equip_code": r.equip_code, "material_batch": r.material_batch, "feeding_time": r.feeding_time} for r in rows]

from __future__ import annotations
from typing import List, Optional, Dict
from sqlalchemy import select
from sqlalchemy.dialects.sqlite import insert as sqlite_insert
from b_infrastructure.database.manager import DatabaseOrchestrator
from b_infrastructure.database.models.models_hot import LatestStatus
from b_infrastructure.utils.sqlite import ensure_table_once
from b_infrastructure.utils.time import to_local_naive
from d_application.dto import StatusSnapshot

class StatusSnapshotRepository:
    def __init__(self, db: DatabaseOrchestrator) -> None:
        self.db = db
        self._init_done = False

    async def initialize(self) -> None:
        if not self._init_done:
            await ensure_table_once(self.db.hot.engine, LatestStatus)
            self._init_done = True

    async def upsert_many(self, items: List[StatusSnapshot]) -> int:
        if not items:
            return 0
        uniq: Dict[str, StatusSnapshot] = {}
        for it in items:
            code = it["equip_code"]
            if not code:
                continue
            uniq[code] = it
        payload = [{"equip_code": it["equip_code"], "equip_status": it.get("equip_status"), "last_update": to_local_naive(it["as_of"])} for it in uniq.values()]
        total = 0
        async with self.db.hot.session() as s:
            base = sqlite_insert(LatestStatus)
            stmt = base.on_conflict_do_update(
                index_elements=[LatestStatus.equip_code],
                set_={"equip_status": base.excluded.equip_status, "last_update": base.excluded.last_update},
                where=base.excluded.last_update > LatestStatus.last_update
            )
            for i in range(0, len(payload), 1000):
                chunk = payload[i:i+1000]
                await s.execute(stmt, chunk)
                total += len(chunk)
        return total

    async def fetch_all(self, codes: Optional[List[str]] = None) -> List[StatusSnapshot]:
        async with self.db.hot.session_read() as s:
            q = select(LatestStatus)
            if codes:
                q = q.where(LatestStatus.equip_code.in_(list({str(c) for c in codes if c})))
            res = await s.execute(q)
            rows = res.scalars().all()
        return [{"equip_code": r.equip_code, "equip_status": r.equip_status, "as_of": r.last_update} for r in rows]

from __future__ import annotations
import asyncio
import contextlib
from typing import List, Tuple, cast
from sqlalchemy import text, bindparam
from sqlalchemy.ext.asyncio import AsyncEngine
from b_infrastructure.database.manager import DatabaseOrchestrator
from b_infrastructure.repositories.cold.input_period import InputPeriodRepository
from b_infrastructure.repositories.cold.status_period import StatusPeriodRepository
from d_application.dto import InputEvent, StatusEvent

class OutboxRepo:
    def __init__(self, engine: AsyncEngine):
        self.engine = engine

    async def initialize(self):
        async with self.engine.begin() as conn:
            await conn.execute(text("""
                CREATE TABLE IF NOT EXISTS outbox_input (
                    equip_code TEXT NOT NULL,
                    material_batch TEXT NOT NULL,
                    feeding_time DATETIME NOT NULL,
                    PRIMARY KEY (equip_code, feeding_time)
                )
            """))
            await conn.execute(text("""
                CREATE TABLE IF NOT EXISTS outbox_status (
                    equip_code TEXT NOT NULL,
                    equip_status TEXT,
                    event_time DATETIME NOT NULL,
                    PRIMARY KEY (equip_code, event_time)
                )
            """))
            await conn.execute(text("""
                CREATE TRIGGER IF NOT EXISTS trg_latest_input_to_outbox_ins
                AFTER INSERT ON latest_input
                BEGIN
                    INSERT OR IGNORE INTO outbox_input (equip_code, material_batch, feeding_time)
                    VALUES (NEW.equip_code, NEW.material_batch, NEW.feeding_time);
                END
            """))
            await conn.execute(text("""
                CREATE TRIGGER IF NOT EXISTS trg_latest_input_to_outbox_upd
                AFTER UPDATE ON latest_input
                WHEN NEW.feeding_time > OLD.feeding_time
                BEGIN
                    INSERT OR IGNORE INTO outbox_input (equip_code, material_batch, feeding_time)
                    VALUES (NEW.equip_code, NEW.material_batch, NEW.feeding_time);
                END
            """))
            await conn.execute(text("""
                CREATE TRIGGER IF NOT EXISTS trg_latest_status_to_outbox_ins
                AFTER INSERT ON latest_status
                BEGIN
                    INSERT OR IGNORE INTO outbox_status (equip_code, equip_status, event_time)
                    VALUES (NEW.equip_code, NEW.equip_status, NEW.last_update);
                END
            """))
            await conn.execute(text("""
                CREATE TRIGGER IF NOT EXISTS trg_latest_status_to_outbox_upd
                AFTER UPDATE ON latest_status
                WHEN NEW.last_update > OLD.last_update
                BEGIN
                    INSERT OR IGNORE INTO outbox_status (equip_code, equip_status, event_time)
                    VALUES (NEW.equip_code, NEW.equip_status, NEW.last_update);
                END
            """))

class OutboxDrainer:
    def __init__(self, db: DatabaseOrchestrator, batch: int = 2000, interval: float = 0.2):
        self.db = db
        self.batch = max(1, batch)
        self.interval = max(0.01, interval)
        self._task = None
        self._stop = asyncio.Event()

    async def start(self):
        ih = InputPeriodRepository(self.db)
        sh = StatusPeriodRepository(self.db)
        await asyncio.gather(ih.initialize(), sh.initialize())
        self._task = asyncio.create_task(self._run(ih, sh))

    async def stop(self):
        self._stop.set()
        if self._task:
            try:
                await asyncio.wait_for(self._task, timeout=5)
            except asyncio.TimeoutError:
                self._task.cancel()
                with contextlib.suppress(Exception):
                    await self._task

    def _pop(self) -> Tuple[List[InputEvent], List[StatusEvent]]:
        rows_inp: List[InputEvent] = []
        rows_sta: List[StatusEvent] = []
        with self.db.hot.sync_engine.begin() as conn:
            r_inp = conn.execute(text("""
                SELECT rowid, equip_code, material_batch, feeding_time
                FROM outbox_input
                ORDER BY feeding_time
                LIMIT :n
            """), {"n": self.batch}).all()
            if r_inp:
                ids = [x[0] for x in r_inp]
                del_in = text("DELETE FROM outbox_input WHERE rowid IN :ids").bindparams(bindparam("ids", expanding=True))
                conn.execute(del_in, {"ids": ids})
                rows_inp = cast(List[InputEvent], [{"equip_code": x[1], "material_batch": x[2], "feeding_time": x[3]} for x in r_inp])
            r_sta = conn.execute(text("""
                SELECT rowid, equip_code, equip_status, event_time
                FROM outbox_status
                ORDER BY event_time
                LIMIT :n
            """), {"n": self.batch}).all()
            if r_sta:
                ids = [x[0] for x in r_sta]
                del_st = text("DELETE FROM outbox_status WHERE rowid IN :ids").bindparams(bindparam("ids", expanding=True))
                conn.execute(del_st, {"ids": ids})
                rows_sta = cast(List[StatusEvent], [{"equip_code": x[1], "equip_status": x[2], "event_time": x[3]} for x in r_sta])
        return rows_inp, rows_sta

    async def _run(self, ih: InputPeriodRepository, sh: StatusPeriodRepository):
        try:
            while not self._stop.is_set():
                rows_inp, rows_sta = await asyncio.to_thread(self._pop)
                if rows_inp:
                    await ih.insert_events(rows_inp)
                if rows_sta:
                    await sh.insert_events(rows_sta)
                if not rows_inp and not rows_sta:
                    try:
                        await asyncio.wait_for(self._stop.wait(), timeout=self.interval)
                    except asyncio.TimeoutError:
                        pass
        except asyncio.CancelledError:
            return

# path: b_infrastructure/repositories/sync_meta.py
from __future__ import annotations
from sqlalchemy import text
from datetime import datetime
from typing import Optional
from sqlalchemy import Table, Column, String, DateTime, MetaData, select
from sqlalchemy.dialects.sqlite import insert
from sqlalchemy.ext.asyncio import AsyncEngine

metadata = MetaData()

sync_meta = Table(
    "sync_meta",
    metadata,
    Column("table_name", String(64), primary_key=True),
    Column("last_synced", DateTime),
)

class SyncMetaRepo:
    def __init__(self, engine: AsyncEngine):
        self.engine = engine

    async def initialize(self):
        async with self.engine.begin() as conn:
            await conn.execute(text("""
                CREATE TABLE IF NOT EXISTS sync_meta (
                    table_name VARCHAR(64) PRIMARY KEY,
                    last_synced DATETIME
                )
            """))

    async def get_last_synced(self, table_name: str) -> Optional[datetime]:
        async with self.engine.begin() as conn:
            result = await conn.execute(select(sync_meta.c.last_synced).where(sync_meta.c.table_name == table_name))
            row = result.first()
            return row[0] if row else None

    async def set_last_synced(self, table_name: str, ts: datetime) -> None:
        async with self.engine.begin() as conn:
            stmt = insert(sync_meta).values(table_name=table_name, last_synced=ts).on_conflict_do_update(
                index_elements=[sync_meta.c.table_name], set_={"last_synced": ts}
            )
            await conn.execute(stmt)

# path: b_infrastructure/utils/layout.py
from __future__ import annotations
import asyncio
import json
from pathlib import Path
from typing import Any, Optional
from a_core.configs.config import get_config

_layout_path_key: Optional[str] = None
_layout_cache: dict[str, Any] = {}
_layout_mtime: float = 0.0
_layout_lock = asyncio.Lock()

async def load_layout() -> dict[str, Any]:
    global _layout_cache, _layout_mtime, _layout_path_key
    async with _layout_lock:
        cfg = get_config()
        path = Path(cfg.layout_path)
        key = str(path.resolve())
        if not path.exists():
            _layout_cache = {}
            _layout_mtime = 0.0
            _layout_path_key = key
            return _layout_cache
        mtime = path.stat().st_mtime
        if _layout_path_key != key or mtime != _layout_mtime:
            def _load() -> dict[str, Any]:
                with path.open("r", encoding="utf-8") as f:
                    return json.load(f)
            _layout_cache = await asyncio.to_thread(_load)
            _layout_mtime = mtime
            _layout_path_key = key
        return _layout_cache
from __future__ import annotations
import asyncio
from sqlalchemy.ext.asyncio import AsyncEngine

_table_init_lock = asyncio.Lock()
_sqlite_pragma_applied: set[int] = set()

async def ensure_table_once(engine: AsyncEngine, model) -> None:
    async with _table_init_lock:
        async with engine.begin() as conn:
            await conn.run_sync(lambda sc: model.metadata.create_all(sc, tables=[model.__table__], checkfirst=True))
            if engine.dialect.name == "sqlite":
                eid = id(engine)
                if eid not in _sqlite_pragma_applied:
                    await conn.exec_driver_sql("PRAGMA journal_mode=WAL")
                    await conn.exec_driver_sql("PRAGMA synchronous=NORMAL")
                    await conn.exec_driver_sql("PRAGMA temp_store=MEMORY")
                    await conn.exec_driver_sql("PRAGMA cache_size=-65536")
                    await conn.exec_driver_sql("PRAGMA mmap_size=268435456")
                    await conn.exec_driver_sql("PRAGMA busy_timeout=15000")
                    _sqlite_pragma_applied.add(eid)

from __future__ import annotations
import asyncio
import queue
import threading
from typing import Any

class AsyncIterFromThread:
    def __init__(self, gen):
        self._gen = gen
        self._q: queue.Queue[Any] = queue.Queue(maxsize=2048)
        self._sentinel = object()
        self._t = threading.Thread(target=self._run, daemon=True)
        self._t.start()

    def _run(self):
        try:
            for item in self._gen:
                self._q.put(item)
        finally:
            self._q.put(self._sentinel)

    def __aiter__(self):
        return self

    async def __anext__(self):
        item = await asyncio.to_thread(self._q.get)
        if item is self._sentinel:
            raise StopAsyncIteration
        return item

from __future__ import annotations
from datetime import datetime, timezone, timedelta
try:
    from zoneinfo import ZoneInfo
except Exception:
    ZoneInfo = None

def local_tz():
    if ZoneInfo:
        try:
            return ZoneInfo("Asia/Ho_Chi_Minh")
        except Exception:
            pass
    return timezone(timedelta(hours=7))

def to_local_naive(dt: datetime) -> datetime:
    if dt is None:
        return dt
    if dt.tzinfo is None:
        return dt
    return dt.astimezone(local_tz()).replace(tzinfo=None)

from __future__ import annotations
import asyncio
import logging
from d_application.services.full_service import FullLoaderService

logger = logging.getLogger(__name__)

class FullLoaderRunner:
    def __init__(self, service: FullLoaderService, interval_sec: int = 30) -> None:
        self.service = service
        self.interval_sec = interval_sec
        self._stopping = asyncio.Event()

    async def start(self) -> None:
        await self.service.initialize()
        try:
            while not self._stopping.is_set():
                try:
                    await self.service.full_sync()
                except Exception as e:
                    logger.error("full_sync failed: %s", e, exc_info=True)
                try:
                    await asyncio.wait_for(self._stopping.wait(), timeout=self.interval_sec)
                except asyncio.TimeoutError:
                    pass
        except asyncio.CancelledError:
            pass

    def stop(self) -> None:
        self._stopping.set()
from __future__ import annotations
import asyncio
import logging
from datetime import datetime
from typing import Optional, List, Callable, Dict, Any
from b_infrastructure.database.manager import DatabaseOrchestrator
from d_application.services.status_service import StatusLoaderService
from d_application.services.input_service import InputLoaderService
from d_application.ports import (
    StatusSnapshotRepoPort,
    StatusHistoryRepoPort,
    StatusPeriodRepoPort,
    InputSnapshotRepoPort,
    InputHistoryRepoPort,
    InputPeriodRepoPort,
    SyncMetaRepoPort,
)

logger = logging.getLogger(__name__)

class FullLoaderService:
    def __init__(
        self,
        db: DatabaseOrchestrator,
        status_snapshots: StatusSnapshotRepoPort,
        status_history: StatusHistoryRepoPort,
        status_periods: StatusPeriodRepoPort,
        input_snapshots: InputSnapshotRepoPort,
        input_history: InputHistoryRepoPort,
        input_periods: InputPeriodRepoPort,
        status_meta: SyncMetaRepoPort,
        input_meta: SyncMetaRepoPort,
    ) -> None:
        self.status_service = StatusLoaderService(db, status_snapshots, status_history, status_periods, status_meta)
        self.input_service = InputLoaderService(db, input_snapshots, input_history, input_periods, input_meta)
        self._initialized = False

    async def initialize(self) -> None:
        if self._initialized:
            return
        await asyncio.gather(self.status_service.initialize(), self.input_service.initialize())
        self._initialized = True

    async def full_sync(self, codes: Optional[List[str]] = None) -> None:
        await asyncio.gather(self.status_service.sync_latest(codes), self.input_service.sync_latest(codes))

    async def sync_from_remote(self, codes: Optional[List[str]] = None) -> None:
        await self.full_sync(codes)

    async def Sync_from_remote(self, codes: Optional[List[str]] = None) -> None:
        await self.sync_from_remote(codes)

    async def sync_status(self, codes: Optional[List[str]] = None):
        await self.status_service.sync_latest(codes)
        return await self.status_service.get_latest(codes)

    async def sync_input(self, codes: Optional[List[str]] = None):
        await self.input_service.sync_latest(codes)
        return await self.input_service.get_latest(codes)

    async def sync_period(self, codes: List[str], start: datetime, end: datetime, progress_cb: Optional[Callable[[str, int], None]] = None) -> None:
        await asyncio.gather(
            self.status_service.sync_period(codes, start, end, progress_cb=progress_cb),
            self.input_service.sync_period(codes, start, end, progress_cb=progress_cb),
        )

    async def query_status_period(self, codes: List[str], start: datetime, end: datetime):
        return await self.status_service.query_period(codes, start, end)

    async def query_input_period(self, codes: List[str], start: datetime, end: datetime):
        return await self.input_service.query_period(codes, start, end)

    async def full_sync_quick(self, codes: Optional[List[str]] = None) -> List[Dict[str, Any]]:
        await self.full_sync(codes)
        statuses, inputs = await asyncio.gather(self.status_service.get_latest(codes), self.input_service.get_latest(codes))
        return [{"status": statuses}, {"input": inputs}]

from __future__ import annotations
import asyncio
from datetime import datetime
from typing import Optional, List, Callable, cast, Set
from b_infrastructure.database.manager import DatabaseOrchestrator
from b_infrastructure.remotes.mssql.remote_input import fetch_latest_input, stream_input_period
from b_infrastructure.utils.layout import load_layout
from d_application.dto import InputEvent, InputSnapshot
from d_application.ports import InputSnapshotRepoPort, InputHistoryRepoPort, InputPeriodRepoPort, SyncMetaRepoPort

async def _resolve_codes() -> List[str]:
    layout = await load_layout()
    floors = layout.get("floors") or {}
    return [str(it.get("id")) for f in floors.values() for it in f.get("items", []) if it.get("id")]

class InputLoaderService:
    def __init__(self, db: DatabaseOrchestrator, snapshots: InputSnapshotRepoPort, history: InputHistoryRepoPort, periods: InputPeriodRepoPort, meta: SyncMetaRepoPort) -> None:
        self.db = db
        self.snapshots = snapshots
        self.history = history
        self.periods = periods
        self.meta = meta
        self._initialized = False

    async def initialize(self) -> None:
        if self._initialized:
            return
        await asyncio.gather(self.snapshots.initialize(), self.history.initialize(), self.periods.initialize(), self.meta.initialize())
        self._initialized = True

    async def sync_latest(self, codes: Optional[List[str]] = None) -> int:
        codes = codes or await _resolve_codes()
        events = cast(List[InputEvent], await fetch_latest_input(self.db, codes))
        if not events:
            return 0
        snaps: List[InputSnapshot] = [{"equip_code": e["equip_code"], "material_batch": e["material_batch"], "feeding_time": e["feeding_time"]} for e in events]
        n1, n2 = await asyncio.gather(self.snapshots.upsert_many(snaps), self.history.insert_events(events))
        return max(n1, n2)

    async def get_latest(self, codes: Optional[List[str]] = None) -> List[InputSnapshot]:
        return await self.snapshots.fetch_all(codes)

    async def sync_period(self, codes: List[str], start: datetime, end: datetime, progress_cb: Optional[Callable[[str, int], None]] = None, backfill: bool = True) -> int:
        codes = codes or await _resolve_codes()
        if backfill:
            fetch_start = start
        else:
            last_synced = await self.meta.get_last_synced("input_period")
            fetch_start = max(start, last_synced) if last_synced else start
        total = 0
        pending: Set[asyncio.Task[int]] = set()
        limit = 4
        async for chunk in stream_input_period(self.db, codes, fetch_start, end):
            t = asyncio.create_task(self.periods.insert_events(cast(List[InputEvent], chunk)))
            pending.add(t)
            if len(pending) >= limit:
                done, pending = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
                for d in done:
                    total += d.result()
                    if progress_cb:
                        progress_cb("input", total)
        if pending:
            results = await asyncio.gather(*pending)
            for r in results:
                total += r
                if progress_cb:
                    progress_cb("input", total)
        last_synced = await self.meta.get_last_synced("input_period")
        if not last_synced or end > last_synced:
            await self.meta.set_last_synced("input_period", end)
        return total

    async def query_period(self, codes: List[str], start: datetime, end: datetime) -> List[InputEvent]:
        res = await self.periods.query_period(codes, start, end)
        return cast(List[InputEvent], res)

from __future__ import annotations
import asyncio
import traceback
from typing import List, Optional, Protocol, runtime_checkable, Callable, Union, Any
from PySide6.QtCore import QObject, QTimer, Signal
from qasync import asyncSlot

@runtime_checkable
class ILoaderService(Protocol):
    async def sync_from_remote(self, codes: Optional[List[str]] = None) -> None: ...

@runtime_checkable
class IFullLoaderService(ILoaderService, Protocol):
    async def full_sync_quick(self, codes: Optional[List[str]] = None) -> List[dict]: ...
    async def sync_period(self, codes: List[str], start, end, progress_cb: Optional[Callable[[str, int], None]] = None) -> None: ...

@runtime_checkable
class Initializable(Protocol):
    async def initialize(self) -> None: ...

class LoadController(QObject):
    progress = Signal(str)
    first_batch_ready = Signal(list)

    def __init__(self, service: Union[ILoaderService, IFullLoaderService], refresh_ms: int, codes: Optional[List[str]] = None, quick_mode: bool = False):
        super().__init__()
        self.service = service
        self.codes = list(codes or [])
        self.quick_mode = quick_mode
        self.poll_timer = QTimer(self)
        self.poll_timer.setInterval(refresh_ms)
        self.poll_timer.timeout.connect(self._poll_status)
        self._started = False
        self._stop_flag = False
        self._first_ready_emitted = False
        self._lock = asyncio.Lock()
        self._current_task: Optional[asyncio.Task[Any]] = None

    def start(self):
        if self._started:
            return
        self._started = True
        self._stop_flag = False
        if isinstance(self.service, Initializable):
            asyncio.create_task(self._safe_initialize())
        self.poll_timer.start()
        self.progress.emit("LoadController started.")

    def stop(self):
        self._stop_flag = True
        self.poll_timer.stop()
        self._started = False
        if self._current_task and not self._current_task.done():
            self._current_task.cancel()
        self.progress.emit("LoadController stopped.")

    async def _safe_initialize(self):
        try:
            await self.service.initialize()  # type: ignore[attr-defined]
            self.progress.emit("Service initialized.")
        except Exception as ex:
            msg = "".join(traceback.format_exception_only(type(ex), ex)).strip()
            self.progress.emit(f"Init error: {msg}")

    @asyncSlot()
    async def _poll_status(self):
        if self._stop_flag or self._lock.locked():
            return
        async with self._lock:
            try:
                self.progress.emit("🔄 Fetching status...")
                if self.quick_mode and hasattr(self.service, "full_sync_quick"):
                    self._current_task = asyncio.create_task(self.service.full_sync_quick(self.codes))  # type: ignore[attr-defined]
                    data = await self._current_task
                    self.progress.emit("✅ HOT quick sync done")
                    if not self._first_ready_emitted:
                        self._first_ready_emitted = True
                        self.first_batch_ready.emit(data)
                        self.progress.emit("First batch ready (quick)")
                else:
                    self._current_task = asyncio.create_task(self.service.sync_from_remote(self.codes))
                    await self._current_task
                    self.progress.emit("✅ Synced from remote")
                    if not self._first_ready_emitted:
                        self._first_ready_emitted = True
                        self.first_batch_ready.emit([{"status": []}, {"input": []}])
                        self.progress.emit("First batch ready")
            except asyncio.CancelledError:
                self.progress.emit("Polling cancelled.")
            except Exception as ex:
                err_msg = "".join(traceback.format_exception_only(type(ex), ex)).strip()
                self.progress.emit(f"❌ Error polling: {err_msg}")
            finally:
                self._current_task = None

from __future__ import annotations
import asyncio
from datetime import datetime
from typing import Optional, List, Callable, cast, Set
from b_infrastructure.database.manager import DatabaseOrchestrator
from b_infrastructure.remotes.mssql.remote_status import fetch_latest_status, stream_status_period
from b_infrastructure.utils.layout import load_layout
from d_application.dto import StatusEvent, StatusSnapshot
from d_application.ports import StatusSnapshotRepoPort, StatusHistoryRepoPort, StatusPeriodRepoPort, SyncMetaRepoPort

async def _resolve_codes() -> List[str]:
    layout = await load_layout()
    floors = layout.get("floors") or {}
    return [str(it.get("id")) for f in floors.values() for it in f.get("items", []) if it.get("id")]

class StatusLoaderService:
    def __init__(self, db: DatabaseOrchestrator, snapshots: StatusSnapshotRepoPort, history: StatusHistoryRepoPort, periods: StatusPeriodRepoPort, meta: SyncMetaRepoPort) -> None:
        self.db = db
        self.snapshots = snapshots
        self.history = history
        self.periods = periods
        self.meta = meta
        self._initialized = False

    async def initialize(self) -> None:
        if self._initialized:
            return
        await asyncio.gather(self.snapshots.initialize(), self.history.initialize(), self.periods.initialize(), self.meta.initialize())
        self._initialized = True

    async def sync_latest(self, codes: Optional[List[str]] = None) -> int:
        codes = codes or await _resolve_codes()
        events = cast(List[StatusEvent], await fetch_latest_status(self.db, codes))
        if not events:
            return 0
        snaps: List[StatusSnapshot] = [{"equip_code": e["equip_code"], "equip_status": e.get("equip_status"), "as_of": e["event_time"]} for e in events]
        n1, n2 = await asyncio.gather(self.snapshots.upsert_many(snaps), self.history.insert_events(events))
        return max(n1, n2)

    async def get_latest(self, codes: Optional[List[str]] = None) -> List[StatusSnapshot]:
        return await self.snapshots.fetch_all(codes)

    async def sync_period(self, codes: List[str], start: datetime, end: datetime, progress_cb: Optional[Callable[[str, int], None]] = None, backfill: bool = True) -> int:
        codes = codes or await _resolve_codes()
        if backfill:
            fetch_start = start
        else:
            last_synced = await self.meta.get_last_synced("status_period")
            fetch_start = max(start, last_synced) if last_synced else start
        total = 0
        pending: Set[asyncio.Task[int]] = set()
        limit = 4
        async for chunk in stream_status_period(self.db, codes, fetch_start, end):
            t = asyncio.create_task(self.periods.insert_events(cast(List[StatusEvent], chunk)))
            pending.add(t)
            if len(pending) >= limit:
                done, pending = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
                for d in done:
                    total += d.result()
                    if progress_cb:
                        progress_cb("status", total)
        if pending:
            results = await asyncio.gather(*pending)
            for r in results:
                total += r
                if progress_cb:
                    progress_cb("status", total)
        last_synced = await self.meta.get_last_synced("status_period")
        if not last_synced or end > last_synced:
            await self.meta.set_last_synced("status_period", end)
        return total

    async def query_period(self, codes: List[str], start: datetime, end: datetime) -> List[StatusEvent]:
        res = await self.periods.query_period(codes, start, end)
        return cast(List[StatusEvent], res)

from __future__ import annotations
import asyncio
import logging
import os
from datetime import datetime
from typing import List, Set, cast
from b_infrastructure.database.manager import DatabaseOrchestrator
from b_infrastructure.remotes.mssql.remote_status import fetch_latest_status, stream_status_period
from b_infrastructure.remotes.mssql.remote_input import fetch_latest_input, stream_input_period
from b_infrastructure.repositories.hot.status_snapshot import StatusSnapshotRepository
from b_infrastructure.repositories.hot.input_snapshot import InputSnapshotRepository
from b_infrastructure.repositories.cold.status_period import StatusPeriodRepository
from b_infrastructure.repositories.cold.input_period import InputPeriodRepository
from b_infrastructure.utils.layout import load_layout
from d_application.dto import StatusEvent, InputEvent, StatusSnapshot, InputSnapshot

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

async def _resolve_codes() -> List[str]:
    layout = await load_layout()
    floors = layout.get("floors", {})
    return [str(item["id"]) for f in floors.values() for item in f.get("items", []) if "id" in item and item["id"]]

async def sync_latest_status(db: DatabaseOrchestrator) -> None:
    codes = await _resolve_codes()
    events = cast(List[StatusEvent], await fetch_latest_status(db, codes))
    if not events:
        return
    snaps: List[StatusSnapshot] = [{"equip_code": e["equip_code"], "equip_status": e.get("equip_status"), "as_of": e["event_time"]} for e in events]
    repo = StatusSnapshotRepository(db)
    await repo.initialize()
    await repo.upsert_many(snaps)

async def sync_latest_input(db: DatabaseOrchestrator) -> None:
    codes = await _resolve_codes()
    events = cast(List[InputEvent], await fetch_latest_input(db, codes))
    if not events:
        return
    snaps: List[InputSnapshot] = [{"equip_code": e["equip_code"], "material_batch": e["material_batch"], "feeding_time": e["feeding_time"]} for e in events]
    repo = InputSnapshotRepository(db)
    await repo.initialize()
    await repo.upsert_many(snaps)

async def sync_status_period(db: DatabaseOrchestrator, codes: List[str], start: datetime, end: datetime) -> None:
    repo = StatusPeriodRepository(db)
    await repo.initialize()
    pending: Set[asyncio.Task[int]] = set()
    limit = max(2, min(8, (os.cpu_count() or 4) // 2))
    async for chunk in stream_status_period(db, codes, start, end):
        t = asyncio.create_task(repo.insert_events(cast(List[StatusEvent], chunk)))
        pending.add(t)
        if len(pending) >= limit:
            done, pending = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
            for d in done:
                _ = d.result()
    if pending:
        await asyncio.gather(*pending)

async def sync_input_period(db: DatabaseOrchestrator, codes: List[str], start: datetime, end: datetime) -> None:
    repo = InputPeriodRepository(db)
    await repo.initialize()
    pending: Set[asyncio.Task[int]] = set()
    limit = max(2, min(8, (os.cpu_count() or 4) // 2))
    async for chunk in stream_input_period(db, codes, start, end):
        t = asyncio.create_task(repo.insert_events(cast(List[InputEvent], chunk)))
        pending.add(t)
        if len(pending) >= limit:
            done, pending = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
            for d in done:
                _ = d.result()
    if pending:
        await asyncio.gather(*pending)

async def full_sync(db: DatabaseOrchestrator) -> None:
    codes = await _resolve_codes()
    if not codes:
        return
    now = datetime.now()
    start = now.replace(hour=0, minute=0, second=0, microsecond=0)
    end = now
    await asyncio.gather(
        sync_latest_status(db),
        sync_latest_input(db),
        sync_status_period(db, codes, start, end),
        sync_input_period(db, codes, start, end),
    )

from __future__ import annotations
from typing import TypedDict, Optional
from datetime import datetime

class StatusEvent(TypedDict):
    equip_code: str
    equip_status: Optional[str]
    event_time: datetime

class InputEvent(TypedDict):
    equip_code: str
    material_batch: str
    feeding_time: datetime

class StatusSnapshot(TypedDict):
    equip_code: str
    equip_status: Optional[str]
    as_of: datetime

class InputSnapshot(TypedDict):
    equip_code: str
    material_batch: str
    feeding_time: datetime

from __future__ import annotations
from typing import Protocol, Optional, List, runtime_checkable
from datetime import datetime
from d_application.dto import StatusEvent, InputEvent, StatusSnapshot, InputSnapshot

@runtime_checkable
class StatusSnapshotRepoPort(Protocol):
    async def initialize(self) -> None: ...
    async def upsert_many(self, items: List[StatusSnapshot]) -> int: ...
    async def fetch_all(self, codes: Optional[List[str]] = None) -> List[StatusSnapshot]: ...

@runtime_checkable
class InputSnapshotRepoPort(Protocol):
    async def initialize(self) -> None: ...
    async def upsert_many(self, items: List[InputSnapshot]) -> int: ...
    async def fetch_all(self, codes: Optional[List[str]] = None) -> List[InputSnapshot]: ...

@runtime_checkable
class StatusHistoryRepoPort(Protocol):
    async def initialize(self) -> None: ...
    async def insert_events(self, events: List[StatusEvent]) -> int: ...
    async def query_period(self, code: str, start: datetime, end: datetime) -> List[StatusEvent]: ...

@runtime_checkable
class InputHistoryRepoPort(Protocol):
    async def initialize(self) -> None: ...
    async def insert_events(self, events: List[InputEvent]) -> int: ...
    async def query_period(self, code: str, start: datetime, end: datetime) -> List[InputEvent]: ...

@runtime_checkable
class StatusPeriodRepoPort(Protocol):
    async def initialize(self) -> None: ...
    async def insert_events(self, events: List[StatusEvent]) -> int: ...
    async def query_period(self, codes: List[str], start: datetime, end: datetime) -> List[StatusEvent]: ...

@runtime_checkable
class InputPeriodRepoPort(Protocol):
    async def initialize(self) -> None: ...
    async def insert_events(self, events: List[InputEvent]) -> int: ...
    async def query_period(self, codes: List[str], start: datetime, end: datetime) -> List[InputEvent]: ...

@runtime_checkable
class SyncMetaRepoPort(Protocol):
    async def initialize(self) -> None: ...
    async def get_last_synced(self, table_name: str) -> Optional[datetime]: ...
    async def set_last_synced(self, table_name: str, ts: datetime) -> None: ...

{
  "floors": {
    "Electrode": {
      "background": "floor1.svg",
      "items": [
        { "id": "CMX01", "x": 250, "y": 360, "label": "Cathode Mixing 01" },
        { "id": "CMX02", "x": 250, "y": 470, "label": "Cathode Mixing 02" },
        { "id": "CMX03", "x": 250, "y": 580, "label": "Cathode Mixing 03" },
        { "id": "AMX01", "x": 250, "y": 1370, "label": "Anode Mixing 01" },
        { "id": "AMX02", "x": 250, "y": 1480, "label": "Anode Mixing 02" },
        { "id": "AMX03", "x": 250, "y": 1590, "label": "Anode Mixing 03" },
        { "id": "AMX04", "x": 250, "y": 1700, "label": "Anode Mixing 04" },
        { "id": "CCT01", "x": 600, "y": 150, "label": "Cathode Coating 01" },
        { "id": "CCTB01", "x": 600, "y": 520, "label": "Cathode Coating 02" },
        { "id": "ACT01", "x": 600, "y": 1250, "label": "Anode Coating 01" },
        { "id": "ACTB01", "x": 600, "y": 750, "label": "Anode Coating 02" },
        { "id": "CCL01", "x": 3450, "y": 400, "label": "Cathode Calendering 01" },
        { "id": "ACL01", "x": 3450, "y": 700, "label": "Anode Calendering 01" },
        { "id": "CLS01", "x": 4150, "y": 360, "label": "Cathode Laser Slitting 01" },
        { "id": "CLS02", "x": 4150, "y": 470, "label": "Cathode Laser Slitting 02" },
        { "id": "CLS03", "x": 4150, "y": 580, "label": "Cathode Laser Slitting 03" },
        { "id": "ASL01", "x": 4150, "y": 720, "label": "Anode Laser Slitting 01" },
        { "id": "ASL02", "x": 4150, "y": 830, "label": "Anode Laser Slitting 02" },
        { "id": "ASL03", "x": 4150, "y": 940, "label": "Anode Laser Slitting 03" }
      ]
    },
    "Assembly": {
      "background": "floor2.svg",
      "items": [
        { "id": "CWD01", "x": 4000, "y": 1605, "label": "Winding 01" },
        { "id": "CWD02", "x": 4000, "y": 1480, "label": "Winding 02" },
        { "id": "CWD03", "x": 4000, "y": 1320, "label": "Winding 03" },
        { "id": "CWD04", "x": 4000, "y": 1195, "label": "Winding 04" },
        { "id": "CWD05", "x": 4000, "y": 1035, "label": "Winding 05" },
        { "id": "CWD06", "x": 4000, "y": 910, "label": "Winding 06" },
        { "id": "CWD07", "x": 4000, "y": 750, "label": "Winding 07" },
        { "id": "CWD08", "x": 4000, "y": 625, "label": "Winding 08" },
        { "id": "CWD09", "x": 4000, "y": 465, "label": "Winding 09" },
        { "id": "CWD10", "x": 4000, "y": 340, "label": "Winding 10" },
        { "id": "CWD11", "x": 4370, "y": 340, "label": "Winding 11" },
        { "id": "CWD12", "x": 4500, "y": 340, "label": "Winding 12" },
        { "id": "CWD13", "x": 4370, "y": 20, "label": "Winding 13" },
        { "id": "CWD14", "x": 4500, "y": 20, "label": "Winding 14" },
        { "id": "CRB11", "x": 3650, "y": 1550, "label": "Rubbing 11" },
        { "id": "CAW11", "x": 3480, "y": 1550, "label": "Anode Collector Welding 11" },
        { "id": "CCW11", "x": 3310, "y": 1550, "label": "Cathode Collector Welding 11" },
        { "id": "CJL11", "x": 3140, "y": 1035, "label": "Jelly roll supply loader 11" },
        { "id": "CCI11", "x": 2960, "y": 1035, "label": "Jelly roll inserting 11" },
        { "id": "CBW11", "x": 2780, "y": 1035, "label": "Bottom welding 11" },
        { "id": "CSG11", "x": 2600, "y": 1035, "label": "Swaging 11" },
        { "id": "CTI11", "x": 2420, "y": 1035, "label": "Insulation Inserting 11" },
        { "id": "CBD11", "x": 2240, "y": 1035, "label": "Beading 11" },
        { "id": "CBC11", "x": 2060, "y": 1035, "label": "Beading check 11" },
        { "id": "CXI11", "x": 1880, "y": 1035, "label": "Xray inspection 11" },
        { "id": "CEJ11", "x": 1700, "y": 1035, "label": "Electrolyte injection 11" },
        { "id": "CHW11", "x": 1520, "y": 1035, "label": "Header welding 11" },
        { "id": "CCR11", "x": 1360, "y": 1035, "label": "Crimping (Sealing)11" },
        { "id": "CWS11", "x": 1180, "y": 1035, "label": "Washing 11" },
        { "id": "COC11", "x": 1000, "y": 1035, "label": "Anti-rust oil coating 11" },
        { "id": "CA111", "x": 820, "y": 1035, "label": "Appearance inspection 1 11" },
        { "id": "CTB11", "x": 640, "y": 1035, "label": "Tubing 11" },
        { "id": "CA211", "x": 460, "y": 1035, "label": "Appearance inspection 2 11" },
        { "id": "CBP11", "x": 280, "y": 1035, "label": "Barcode Printing 11" },
        { "id": "CCU11", "x": 100, "y": 1035, "label": "Cell Collection Unloader 11" }
      ]
    }
  }
}

from __future__ import annotations
from typing import List, Optional, Any, Callable, Tuple
from datetime import datetime, timedelta
from PySide6.QtCore import (
    Qt, QModelIndex, QTimer, QSettings, QByteArray, QPoint, QEvent, 
    QThreadPool, QRegularExpression
)
from PySide6.QtGui import QAction, QKeySequence, QColor, QBrush
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QLabel, QWidget, QLineEdit, QTableView, QMenu, 
    QMessageBox, QHBoxLayout, QComboBox, QCheckBox, QToolButton, QHeaderView, 
    QAbstractItemView, QApplication
)
from e_ui.theme import theme_bus, theme_colors, current_theme_name
from e_ui.table_models import TableDataModel, ExtendedSortFilterProxyModel
from e_ui.table_delegates import CellDelegate
from e_ui.loading_overlay import LoadingOverlay
from e_ui.chart_dialog import ColumnChartDialog
from e_ui.indexing import IndexSignals, IndexTask
from e_ui.utils import to_datetime

class BaseTableDialog(QDialog):
    SETTINGS_ORG = "MyCompany"
    SETTINGS_APP = "MyTablesApp"

    def __init__(self, parent: QWidget, title: str, headers: List[str]) -> None:
        super().__init__(parent)
        self.setWindowTitle(title)
        self.resize(1000, 640)
        self._headers = headers[:]
        self._settings = QSettings(self.SETTINGS_ORG, self.SETTINGS_APP)
        self._theme_name = current_theme_name()
        self._status_col: Optional[int] = None
        self._status_alpha_light = 56
        self._status_alpha_dark = 72
        self._highlight_threshold = 50000
        self._indexing_threshold = 30000
        self._page_size = 2000
        self._time_col_idx: Optional[int] = None
        self._all_rows: List[List[Any]] = []
        self._loaded_count = 0
        self._indexing_token = 0
        self._indexing_running = False
        self._pool = QThreadPool.globalInstance()
        self.model = TableDataModel(headers, parent=self)
        self.proxy = ExtendedSortFilterProxyModel(self)
        self.proxy.setSourceModel(self.model)
        self.proxy.setDynamicSortFilter(True)
        self._setup_ui()
        self._setup_actions()
        self._setup_connections()
        self._restore_settings()
        self._autosize_columns(initial=True)
        self._apply_filter()
        self._update_counts()

    def _setup_ui(self):
        root = QVBoxLayout(self)
        top = QHBoxLayout()
        self.cmb_column = QComboBox(self)
        self.cmb_column.addItem("All columns (*)", -1)
        for i, h in enumerate(self._headers):
            self.cmb_column.addItem(h, i)
        self.cmb_column.setToolTip("Choose a column to filter, or all columns")
        self.search = QLineEdit(self)
        self.search.setPlaceholderText("Search...")
        self.search.setClearButtonEnabled(True)
        self.chk_regex = QCheckBox("Regex", self)
        self.chk_case = QCheckBox("Aa", self)
        self.chk_case.setToolTip("Case sensitive")
        self.chk_exact = QCheckBox("Exact", self)
        self.chk_exact.setToolTip("Exact match")
        self.chk_no_accent = QCheckBox("No accents", self)
        self.chk_no_accent.setToolTip("Accent-insensitive (Vietnamese)")
        self.cmb_logic = QComboBox(self)
        self.cmb_logic.addItems(["OR", "AND"])
        self.cmb_logic.setToolTip("Combine tokens: OR or AND")
        btn_clear = QToolButton(self)
        btn_clear.setText("Clear")
        btn_clear.setToolTip("Clear filter")
        btn_clear.clicked.connect(self._clear_filter)
        top.addWidget(QLabel("Column:", self))
        top.addWidget(self.cmb_column, 0)
        top.addSpacing(8)
        top.addWidget(QLabel("Filter:", self))
        top.addWidget(self.search, 1)
        top.addWidget(self.cmb_logic)
        top.addWidget(self.chk_no_accent)
        top.addWidget(self.chk_regex)
        top.addWidget(self.chk_case)
        top.addWidget(self.chk_exact)
        top.addWidget(btn_clear)
        root.addLayout(top)
        self.table = QTableView(self)
        self.table.setModel(self.proxy)
        self.table.setSortingEnabled(True)
        self.table.setAlternatingRowColors(True)
        self.table.setSelectionBehavior(QTableView.SelectionBehavior.SelectItems)
        self.table.setSelectionMode(QTableView.SelectionMode.ExtendedSelection)
        self.table.setWordWrap(False)
        self.table.setCornerButtonEnabled(True)
        self.table.setEditTriggers(QAbstractItemView.NoEditTriggers)
        self.table.verticalHeader().setVisible(True)
        self.table.verticalHeader().setDefaultSectionSize(22)
        hh = self.table.horizontalHeader()
        hh.setStretchLastSection(False)
        hh.setSectionsMovable(True)
        hh.setHighlightSections(False)
        hh.setContextMenuPolicy(Qt.CustomContextMenu)
        hh.customContextMenuRequested.connect(self._show_header_menu)
        self.table.setContextMenuPolicy(Qt.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self._show_table_menu)
        self.table.doubleClicked.connect(self.show_row_detail)
        self._delegate = CellDelegate(
            self.table,
            get_regex=self._current_regex,
            should_highlight_col=self._should_highlight_col,
            get_cell_bg=self._cell_background_for_index,
            highlight_brush=self._make_highlight_brush()
        )
        self.table.setItemDelegate(self._delegate)
        root.addWidget(self.table, 1)
        nav = QHBoxLayout()
        self.lbl_page = QLabel("0 rows", self)
        nav.addWidget(self.lbl_page, 0)
        nav.addStretch(1)
        self.btn_latest = QToolButton(self)
        self.btn_latest.setText("Latest")
        self.btn_latest.setToolTip("Show latest page")
        self.btn_latest.clicked.connect(self._on_latest)
        nav.addWidget(self.btn_latest)
        self.btn_load_more = QToolButton(self)
        self.btn_load_more.setText("Load more")
        self.btn_load_more.clicked.connect(self._on_load_more)
        nav.addWidget(self.btn_load_more)
        self.btn_autosize = QToolButton(self)
        self.btn_autosize.setText("Autosize")
        self.btn_autosize.setToolTip("Auto fit column width to contents")
        self.btn_autosize.clicked.connect(self._autosize_columns)
        nav.addWidget(self.btn_autosize)
        self.btn_chart = QToolButton(self)
        self.btn_chart.setText("Chart")
        self.btn_chart.setToolTip("Open column chart")
        self.btn_chart.clicked.connect(self._open_chart)
        nav.addWidget(self.btn_chart)
        root.addLayout(nav)
        self._default_header_state: QByteArray = hh.saveState()
        self._overlay = LoadingOverlay(self.table.viewport())
        self.table.viewport().installEventFilter(self)
        self._period_key: str = "1d"
        theme_bus.changed.connect(self._on_theme_changed)
        self.setWindowFlags(self.windowFlags() | Qt.Window | Qt.WindowMinMaxButtonsHint | Qt.WindowCloseButtonHint)
        self.setWindowFlag(Qt.WindowContextHelpButtonHint, False)
        self.setSizeGripEnabled(True)

    def _setup_actions(self):
        act_copy = QAction("Copy", self)
        act_copy.setShortcut(QKeySequence.Copy)
        act_copy.triggered.connect(self.copy_selection_to_clipboard)
        self.table.addAction(act_copy)
        act_copy_nohdr = QAction("Copy (no headers)", self)
        act_copy_nohdr.setShortcut("Ctrl+Shift+C")
        act_copy_nohdr.triggered.connect(lambda: self.copy_selection_to_clipboard(with_headers=False))
        self.table.addAction(act_copy_nohdr)
        act_select_all = QAction("Select All", self)
        act_select_all.setShortcut(QKeySequence.SelectAll)
        act_select_all.triggered.connect(self.table.selectAll)
        self.table.addAction(act_select_all)
        act_focus_search = QAction("Focus Search", self)
        act_focus_search.setShortcut("Ctrl+F")
        act_focus_search.triggered.connect(self.search.setFocus)
        self.addAction(act_focus_search)
        act_clear = QAction("Clear Filter", self)
        act_clear.setShortcut(QKeySequence(Qt.Key_Escape))
        act_clear.triggered.connect(self._escape_action)
        self.addAction(act_clear)

    def _setup_connections(self):
        self._filter_timer = QTimer(self)
        self._filter_timer.setSingleShot(True)
        self._filter_timer.setInterval(300)
        self._filter_timer.timeout.connect(self._apply_filter)
        self.search.textChanged.connect(self._on_filter_input_changed)
        self.cmb_column.currentIndexChanged.connect(self._apply_filter)
        self.chk_regex.toggled.connect(self._apply_filter)
        self.chk_case.toggled.connect(self._apply_filter)
        self.chk_exact.toggled.connect(self._apply_filter)
        self.chk_no_accent.toggled.connect(self._apply_filter)
        self.cmb_logic.currentIndexChanged.connect(self._apply_filter)
        self.proxy.rowsInserted.connect(self._update_counts)
        self.proxy.rowsRemoved.connect(self._update_counts)
        self.proxy.modelReset.connect(self._update_counts)
        self.proxy.layoutChanged.connect(self._update_counts)
        self.table.selectionModel().selectionChanged.connect(self._update_counts)

    def set_period_key(self, key: str):
        self._period_key = key or "1d"

    def _period_range_for_key(self, key: str) -> tuple[datetime, datetime]:
        now = datetime.now()
        today0 = now.replace(hour=0, minute=0, second=0, microsecond=0)
        if key == "1d":
            start = today0
            end_axis = today0 + timedelta(days=1)
        elif key == "1w":
            start = today0 - timedelta(days=6)
            end_axis = today0 + timedelta(days=1)
        elif key == "1m":
            start = today0 - timedelta(days=29)
            end_axis = today0 + timedelta(days=1)
        elif key == "3m":
            start = today0 - timedelta(days=89)
            end_axis = today0 + timedelta(days=1)
        elif key == "6m":
            start = today0 - timedelta(days=179)
            end_axis = today0 + timedelta(days=1)
        else:
            start = today0 - timedelta(days=29)
            end_axis = today0 + timedelta(days=1)
        return start, end_axis

    def _rows_events(self) -> list[tuple[datetime, Optional[str]]]:
        try:
            h = self.model.headers()
            t_idx = h.index("event_time")
            s_idx = h.index("equip_status") if "equip_status" in h else -1
        except Exception:
            return []
        out = []
        for r in self._all_rows:
            t = r[t_idx] if t_idx < len(r) else None
            dt = to_datetime(t)
            if not dt:
                continue
            st = r[s_idx] if 0 <= s_idx < len(r) else None
            st = str(st) if st is not None else None
            out.append((dt, st))
        out.sort(key=lambda x: x[0])
        return out

    def _build_segments_in_range(self, events: list[tuple[datetime, Optional[str]]], 
                                 start: datetime, clip_end: datetime) -> list[tuple[datetime, datetime, Optional[str]]]:
        segs: list[tuple[datetime, datetime, Optional[str]]] = []
        if clip_end <= start:
            return segs
        initial_status: Optional[str] = None
        for t, s in events:
            if t < start:
                initial_status = s
            else:
                break
        cur_t = start
        cur_status = initial_status
        for t, s in events:
            if t < start:
                continue
            if t > clip_end:
                break
            if cur_t < t:
                segs.append((cur_t, t, cur_status))
            cur_t = t
            cur_status = s
        if cur_t < clip_end:
            segs.append((cur_t, clip_end, cur_status))
        return segs

    def _bucket_edges(self, key: str, start: datetime, end_axis: datetime, 
                      clip_end: datetime) -> tuple[list[str], list[tuple[datetime, datetime]], str, list[float]]:
        edges: list[tuple[datetime, datetime]] = []
        labels: list[str] = []
        bucket_totals: list[float] = []
        if key == "1d":
            unit = "min"
            day0 = start
            for i in range(24):
                a = day0 + timedelta(hours=i)
                b = day0 + timedelta(hours=i + 1)
                labels.append(f"{i:02d}h")
                eff_b = min(b, clip_end)
                if eff_b > a:
                    bucket_totals.append((eff_b - a).total_seconds() / 60.0)
                else:
                    bucket_totals.append(0.0)
                edges.append((a, b))
        else:
            unit = "h"
            day = start
            while day < end_axis:
                a = day
                b = day + timedelta(days=1)
                labels.append(a.strftime("%d/%m"))
                eff_b = min(b, clip_end)
                if eff_b > a:
                    bucket_totals.append((eff_b - a).total_seconds() / 3600.0)
                else:
                    bucket_totals.append(0.0)
                edges.append((a, b))
                day = b
        return labels, edges, unit, bucket_totals

    def _accumulate_by_bucket(self, segs: list[tuple[datetime, datetime, Optional[str]]], 
                              edges: list[tuple[datetime, datetime]], 
                              unit: str) -> tuple[dict[str, list[float]], list[str]]:
        data: dict[str, list[float]] = {}
        for _, _, st in segs:
            if st is None:
                continue
            if st not in data:
                data[st] = [0.0] * len(edges)
        for (s, e, st) in segs:
            if st is None:
                continue
            for i, (ba, bb) in enumerate(edges):
                a = max(s, ba)
                b = min(e, bb)
                if b <= a:
                    continue
                val = (b - a).total_seconds()
                if unit == "min":
                    val /= 60.0
                else:
                    val /= 3600.0
                data.setdefault(st, [0.0] * len(edges))
                data[st][i] += val
        ordered_statuses = list(data.keys())
        return data, ordered_statuses

    def _open_chart(self):
        h = self.model.headers()
        if "equip_status" not in h or "event_time" not in h:
            QMessageBox.information(self, "Chart", "Không có dữ liệu trạng thái để vẽ chart.")
            return
        if not self._all_rows:
            QMessageBox.information(self, "Chart", "Không có dữ liệu.")
            return
        s, e_axis = self._period_range_for_key(self._period_key)
        now = datetime.now()
        clip_end = min(e_axis, now)
        events = self._rows_events()
        segs = self._build_segments_in_range(events, s, clip_end)
        labels, edges, unit, bucket_totals = self._bucket_edges(self._period_key, s, e_axis, clip_end)
        data, ordered_statuses = self._accumulate_by_bucket(segs, edges, unit)
        if not data:
            QMessageBox.information(self, "Chart", "Không có dữ liệu trong khoảng được chọn.")
            return
        colors = theme_colors(self._theme_name)
        status_map = colors["status"]
        color_map = {st: QColor(str(status_map.get(st, status_map.get(None, "#80808040")))) for st in ordered_statuses}
        title = f"{self.windowTitle()} • {self._period_key.upper()} column chart"
        dlg = ColumnChartDialog(self, title, labels, data, ordered_statuses, unit, bucket_totals, color_map, theme=self._theme_name)
        dlg.setWindowModality(Qt.WindowModality.ApplicationModal)
        dlg.resize(900, 520)
        dlg.exec()

    def set_page_size(self, n: int):
        self._page_size = max(100, int(n))

    def set_time_column_by_header(self, header_name: str):
        try:
            idx = self._headers.index(header_name)
        except ValueError:
            idx = None
        self._time_col_idx = idx

    def set_status_column(self, col: int):
        self._status_col = col
        self.table.viewport().update()

    def _on_theme_changed(self, name: str, colors: object):
        self._theme_name = name
        self._delegate.set_highlight_brush(self._make_highlight_brush())
        self.table.viewport().update()

    def _make_highlight_brush(self) -> QBrush:
        colors = theme_colors(self._theme_name)
        accent = str(colors["primary"])
        c = QColor(accent)
        c.setAlpha(56 if self._theme_name == "light" else 76)
        return QBrush(c)

    def start_loading(self, text: str = "Đang tải dữ liệu..."):
        self._overlay.start(text)

    def set_loading_text(self, text: str):
        self._overlay.set_text(text)

    def stop_loading(self):
        self._overlay.stop()

    def eventFilter(self, obj, ev):
        if obj is self.table.viewport() and ev.type() == QEvent.Resize:
            if self._overlay.isVisible():
                self._overlay.resize(self.table.viewport().size())
        return super().eventFilter(obj, ev)

    def clear_rows(self):
        self._all_rows = []
        self._loaded_count = 0
        self.model.clear()
        self._update_counts()
        self._update_nav()

    def _sorted_all_rows(self) -> List[List[Any]]:
        if self._time_col_idx is None:
            return self._all_rows[:]
        idx = self._time_col_idx
        def key_fn(r: List[Any]):
            dt = to_datetime(r[idx] if idx < len(r) else None)
            return dt or datetime.min
        return sorted(self._all_rows, key=key_fn, reverse=True)

    def _apply_pagination(self):
        if not self._all_rows:
            self.model.set_rows([])
            self._update_nav()
            return
        self._loaded_count = min(self._loaded_count or self._page_size, len(self._all_rows))
        sorted_rows = self._sorted_all_rows()
        view_rows = sorted_rows[: self._loaded_count]
        self.model.set_rows(view_rows)
        self._update_nav()
        self._start_indexing_if_needed()
        self._apply_filter()

    def load_rows(self, rows: List[List[Any]]):
        self._all_rows = rows[:]
        self._loaded_count = min(len(self._all_rows), self._page_size)
        self._apply_pagination()
        self._autosize_columns(initial=True)

    def _on_load_more(self):
        if not self._all_rows:
            return
        if self._loaded_count >= len(self._all_rows):
            return
        self._loaded_count = min(len(self._all_rows), self._loaded_count + self._page_size)
        self._apply_pagination()

    def _on_latest(self):
        if not self._all_rows:
            return
        self._loaded_count = min(self._page_size, len(self._all_rows))
        self._apply_pagination()

    def show_row_detail(self, index: QModelIndex):
        row = index.row()
        cols = range(self.proxy.columnCount())
        row_data = [self.proxy.data(self.proxy.index(row, c)) for c in cols]
        text = "\n".join(f"{self.model.headerData(i, Qt.Orientation.Horizontal)}: {row_data[i]}" for i in cols)
        QMessageBox.information(self, "Row Detail", text)

    def copy_selection_to_clipboard(self, with_headers: bool = True, sep: str = "\t"):
        sm = self.table.selectionModel()
        if not sm or not sm.hasSelection():
            return
        indexes = sm.selectedIndexes()
        rows = sorted({i.row() for i in indexes})
        hh = self.table.horizontalHeader()
        cols = sorted({i.column() for i in indexes}, key=lambda c: hh.visualIndex(c))
        sel_set = {(i.row(), i.column()) for i in indexes}
        lines = []
        if with_headers:
            headers = [self.model.headerData(c, Qt.Horizontal) for c in cols]
            lines.append(sep.join(str(h) for h in headers))
        for r in rows:
            vals = []
            for c in cols:
                vals.append("" if (r, c) not in sel_set else str(self.proxy.index(r, c).data() or ""))
            lines.append(sep.join(vals))
        QApplication.clipboard().setText("\n".join(lines))

    def _escape_action(self):
        if self.search.text():
            self._clear_filter()
        else:
            self.close()

    def _on_filter_input_changed(self, _):
        self._filter_timer.start()

    def _apply_filter(self):
        sorting = self.table.isSortingEnabled()
        self.table.setSortingEnabled(False)
        text = self.search.text()
        exact = self.chk_exact.isChecked()
        is_regex = self.chk_regex.isChecked()
        case_sensitive = self.chk_case.isChecked()
        ignore_accents = self.chk_no_accent.isChecked()
        logic_and = self.cmb_logic.currentText() == "AND"
        col = self.cmb_column.currentData()
        key_col = int(col) if isinstance(col, int) else -1
        self.proxy.setFilterParams(
            text=text,
            is_regex=is_regex,
            exact=exact,
            case_sensitive=case_sensitive,
            ignore_accents=ignore_accents,
            logic_and=logic_and,
            key_col=key_col,
        )
        self._maybe_index_for_filter()
        self._update_counts()
        self.table.viewport().update()
        self.table.setSortingEnabled(sorting)

    def _clear_filter(self):
        self.search.clear()
        self.chk_regex.setChecked(False)
        self.chk_case.setChecked(False)
        self.chk_exact.setChecked(False)
        self.chk_no_accent.setChecked(True)
        self.cmb_logic.setCurrentIndex(0)
        self.cmb_column.setCurrentIndex(0)
        self._apply_filter()

    def _maybe_index_for_filter(self):
        if self.model.rowCount() < self._indexing_threshold:
            return
        key_col = self.cmb_column.currentData()
        if not isinstance(key_col, int):
            key_col = -1
        if key_col < 0:
            cols = tuple(range(self.model.columnCount()))
        else:
            cols = (key_col,)
        case_sensitive = self.chk_case.isChecked()
        ignore_accents = self.chk_no_accent.isChecked()
        self._start_indexing(cols, case_sensitive, ignore_accents)

    def _start_indexing_if_needed(self):
        if self.model.rowCount() < self._indexing_threshold:
            return
        key_col = self.cmb_column.currentData()
        if not isinstance(key_col, int):
            key_col = -1
        if key_col < 0:
            cols = tuple(range(self.model.columnCount()))
        else:
            cols = (key_col,)
        case_sensitive = self.chk_case.isChecked()
        ignore_accents = self.chk_no_accent.isChecked()
        self._start_indexing(cols, case_sensitive, ignore_accents)

    def _start_indexing(self, cols: Tuple[int, ...], case_sensitive: bool, ignore_accents: bool):
        if self._indexing_running:
            return
        rows_snapshot = [r[:] for r in self.model._rows]
        token = self._indexing_token + 1
        self._indexing_token = token
        self._overlay.start("Indexing...")
        sig = IndexSignals()
        sig.finished.connect(self._on_index_done)
        sig.error.connect(self._on_index_error)
        task = IndexTask(rows_snapshot, cols, case_sensitive, ignore_accents, token, sig)
        self._pool.start(task)

    def _on_index_done(self, cache: object, cols_key: tuple, norm_key: tuple, token: int):
        if token != self._indexing_token:
            self._indexing_running = False
            self._overlay.stop()
            return
        cache_list = cache if isinstance(cache, list) else []
        self.proxy.set_prebuilt_cache(cache_list, tuple(cols_key), tuple(norm_key))
        self._indexing_running = False
        self._overlay.stop()

    def _on_index_error(self, msg: str, token: int):
        self._indexing_running = False
        self._overlay.stop()

    def _update_counts(self):
        total_all = len(self._all_rows)
        total = self.model.rowCount()
        visible = self.proxy.rowCount()
        selected = len(self.table.selectionModel().selectedRows())
        hh = self.table.horizontalHeader()
        vis_cols = sum(1 for i in range(hh.count()) if not hh.isSectionHidden(i))
        self.lbl_page.setText(f"Rows: {visible}/{total} of {total_all} | Selected: {selected} | Cols: {vis_cols}/{hh.count()}")

    def _update_nav(self):
        rem = max(0, len(self._all_rows) - self._loaded_count)
        self.btn_load_more.setEnabled(rem > 0)
        self.btn_load_more.setText(f"Load more (+{min(self._page_size, rem)})")

    def _should_highlight_col(self, col: int) -> bool:
        key_col = self.cmb_column.currentData()
        key_col = int(key_col) if isinstance(key_col, int) else -1
        if self.model.rowCount() > self._highlight_threshold and key_col < 0:
            return False
        return key_col == -1 or col == key_col

    def _current_regex(self) -> Optional[QRegularExpression]:
        return self.proxy.highlight_regex()

    def _cell_background_for_index(self, index: QModelIndex) -> Optional[QBrush]:
        if self._status_col is None:
            return None
        if index.column() != self._status_col:
            return None
        val = index.data()
        if not isinstance(val, str):
            val = str(val) if val is not None else ""
        colors = theme_colors(self._theme_name)
        status_map = colors["status"]
        hexc = status_map.get(val, status_map.get(None, "#00000000"))
        c = QColor(hexc)
        c.setAlpha(self._status_alpha_light if self._theme_name == "light" else self._status_alpha_dark)
        return QBrush(c)

    def _autosize_columns(self, initial: bool = False):
        hh = self.table.horizontalHeader()
        hh.setSectionResizeMode(QHeaderView.ResizeToContents)
        maxw = 600
        for c in range(self.model.columnCount()):
            w = min(self.table.columnWidth(c), maxw)
            self.table.setColumnWidth(c, max(w, 80))
        hh.setSectionResizeMode(QHeaderView.Interactive)
        if not initial:
            self._save_settings()

    def _show_table_menu(self, pos: QPoint):
        menu = QMenu(self)
        menu.addSeparator()
        act_copy = QAction("Copy (Ctrl+C)", self)
        act_copy.triggered.connect(self.copy_selection_to_clipboard)
        menu.addAction(act_copy)
        act_copy_nohdr = QAction("Copy (no headers) (Ctrl+Shift+C)", self)
        act_copy_nohdr.triggered.connect(lambda: self.copy_selection_to_clipboard(with_headers=False))
        menu.addAction(act_copy_nohdr)
        menu.addSeparator()
        act_auto = QAction("Autosize columns", self)
        act_auto.triggered.connect(self._autosize_columns)
        menu.addAction(act_auto)
        act_latest = QAction("Show Latest", self)
        act_latest.triggered.connect(self._on_latest)
        menu.addAction(act_latest)
        act_reset_cols = QAction("Reset columns", self)
        act_reset_cols.triggered.connect(self._reset_columns)
        menu.addAction(act_reset_cols)
        menu.exec(self.table.viewport().mapToGlobal(pos))

    def _show_header_menu(self, pos: QPoint):
        menu = QMenu(self)
        hh = self.table.horizontalHeader()
        for visual in range(hh.count()):
            logical = hh.logicalIndex(visual)
            text = str(self.model.headerData(logical, Qt.Horizontal))
            act = QAction(text, self)
            act.setCheckable(True)
            act.setChecked(not hh.isSectionHidden(logical))
            act.toggled.connect(lambda checked, col=logical: hh.setSectionHidden(col, not checked))
            menu.addAction(act)
        menu.addSeparator()
        act_reset = QAction("Reset columns", self)
        act_reset.triggered.connect(self._reset_columns)
        menu.addAction(act_reset)
        menu.exec(self.table.horizontalHeader().viewport().mapToGlobal(pos))

    def _reset_columns(self):
        hh = self.table.horizontalHeader()
        hh.restoreState(self._default_header_state)
        self._autosize_columns()
        self._save_settings()

    def _current_column_order(self, visible_only: bool = True) -> List[int]:
        hh = self.table.horizontalHeader()
        order = []
        for visual in range(hh.count()):
            logical = hh.logicalIndex(visual)
            if visible_only and hh.isSectionHidden(logical):
                continue
            order.append(logical)
        return order

    def _settings_key(self) -> str:
        return f"BaseTableDialog/{self.windowTitle()}"

    def _save_settings(self):
        key = self._settings_key()
        self._settings.beginGroup(key)
        self._settings.setValue("geometry", self.saveGeometry())
        self._settings.setValue("header", self.table.horizontalHeader().saveState())
        self._settings.endGroup()

    def _restore_settings(self):
        key = self._settings_key()
        self._settings.beginGroup(key)
        geo = self._settings.value("geometry")
        hdr = self._settings.value("header")
        self._settings.endGroup()
        if isinstance(geo, QByteArray):
            self.restoreGeometry(geo)
        if isinstance(hdr, QByteArray):
            self.table.horizontalHeader().restoreState(hdr)

    def closeEvent(self, e):
        self._save_settings()
        super().closeEvent(e)

from __future__ import annotations
from typing import Dict, List, Optional
from PySide6.QtCore import Qt
from PySide6.QtGui import QColor, QBrush, QPainter, QCursor
from PySide6.QtWidgets import QDialog, QVBoxLayout, QWidget, QToolTip
from PySide6.QtCharts import QChart, QChartView, QStackedBarSeries, QBarSet, QBarCategoryAxis, QValueAxis

class ColumnChartDialog(QDialog):
    def __init__(self, parent: QWidget, title: str, categories: List[str], 
                 data: Dict[str, List[float]], ordered_statuses: List[str], 
                 unit: str, bucket_totals: List[float], 
                 color_map: Dict[str, QColor], theme: str = "light"):
        super().__init__(parent)
        self.setWindowTitle(title)
        lay = QVBoxLayout(self)
        lay.setContentsMargins(8, 8, 8, 8)
        chart = QChart()
        chart.setTitle(title)
        series = QStackedBarSeries()
        for st in ordered_statuses:
            vals = data.get(st, [0.0] * len(categories))
            bs = QBarSet(st or "Unknown")
            bs.append(vals)
            col = color_map.get(st)
            if col is not None:
                bs.setColor(col)
                fill = QColor(col)
                fill.setAlpha(220 if theme == "light" else 200)
                bs.setBrush(QBrush(fill))
                bs.setBorderColor(col.darker(120))
            series.append(bs)
        chart.addSeries(series)
        axisX = QBarCategoryAxis()
        axisX.append(categories)
        axisX.setLabelsAngle(-90)
        chart.addAxis(axisX, Qt.AlignBottom)
        series.attachAxis(axisX)
        axisY = QValueAxis()
        axisY.setLabelFormat("%.0f" if unit == "min" else "%.1f")
        axisY.setTitleText("Minutes" if unit == "min" else "Hours")
        ymax = max(bucket_totals) if bucket_totals else (60.0 if unit == "min" else 24.0)
        if ymax <= 0:
            ymax = 1.0
        axisY.setRange(0, ymax)
        chart.addAxis(axisY, Qt.AlignLeft)
        series.attachAxis(axisY)
        chart.legend().setVisible(True)
        chart.legend().setAlignment(Qt.AlignBottom)
        view = QChartView(chart)
        view.setRenderHint(QPainter.Antialiasing, True)
        lay.addWidget(view)
        
        def on_hover(status: bool, index: int, barset: QBarSet):
            if not status:
                QToolTip.hideText()
                return
            st = barset.label()
            val = barset.at(index)
            total = bucket_totals[index] if 0 <= index < len(bucket_totals) else 0.0
            pct = (val / total * 100.0) if total > 0 else 0.0
            if unit == "min":
                txt_val = f"{val:.0f} min"
            else:
                minutes = int(round(val * 60))
                h = minutes // 60
                m = minutes % 60
                txt_val = f"{h}h {m}m" if h > 0 else f"{m}m"
            cat = categories[index] if 0 <= index < len(categories) else ""
            tip = f"{cat}\n{st}: {txt_val} ({pct:.1f}%)"
            QToolTip.showText(QCursor.pos(), tip, self)
        
        series.hovered.connect(on_hover)
        self.setWindowFlags(self.windowFlags() | Qt.Window | Qt.WindowMinMaxButtonsHint | Qt.WindowCloseButtonHint)
        self.setWindowFlag(Qt.WindowContextHelpButtonHint, False)
        self.setSizeGripEnabled(True)
from __future__ import annotations
from typing import List
from e_ui.base_dialog import BaseTableDialog

class StatusDialog(BaseTableDialog):
    def __init__(self, parent, equip_code: str, rows: List[dict]):
        headers = ["equip_code", "equip_status", "event_time"]
        super().__init__(parent, f"Status {equip_code}", headers)
        self.set_status_column(1)
        self.set_time_column_by_header("event_time")
        formatted = [[r.get("equip_code", ""), r.get("equip_status", ""), r.get("event_time", "")] for r in rows]
        self.load_rows(formatted)

class WipDialog(BaseTableDialog):
    def __init__(self, parent, equip_code: str, rows: List[dict]):
        headers = ["equip_code", "equip_status", "event_time"]
        super().__init__(parent, f"WIP {equip_code}", headers)
        self.set_status_column(1)
        self.set_time_column_by_header("event_time")
        formatted = [[r.get("equip_code", ""), r.get("equip_status", ""), r.get("event_time", "")] for r in rows]
        self.load_rows(formatted)

class EipDialog(BaseTableDialog):
    def __init__(self, parent, equip_code: str, rows: List[dict]):
        headers = ["equip_code", "equip_status", "event_time"]
        super().__init__(parent, f"EIP {equip_code}", headers)
        self.set_status_column(1)
        self.set_time_column_by_header("event_time")
        formatted = [[r.get("equip_code", ""), r.get("equip_status", ""), r.get("event_time", "")] for r in rows]
        self.load_rows(formatted)

class InputDialog(BaseTableDialog):
    def __init__(self, parent, equip_code: str, rows: List[dict]):
        headers = ["equip_code", "material_batch", "feeding_time"]
        super().__init__(parent, f"Input {equip_code}", headers)
        self.set_time_column_by_header("feeding_time")
        formatted = [[r.get("equip_code", ""), r.get("material_batch", ""), r.get("feeding_time", "")] for r in rows]
        self.load_rows(formatted)

from __future__ import annotations
from typing import List, Optional, Tuple
from datetime import datetime, timedelta
from bisect import bisect_right
from PySide6.QtCore import Qt, QRectF, QSize, QPointF, Signal
from PySide6.QtGui import QColor, QPainter, QPen, QBrush, QFont, QCursor
from PySide6.QtWidgets import QWidget, QToolTip
from e_ui.theme import theme_bus, theme_colors, current_theme_name

def _fmt_dur(seconds: float) -> str:
    secs = int(max(0, seconds) + 0.5)
    h = secs // 3600
    m = (secs % 3600) // 60
    s = secs % 60
    if h > 0:
        return f"{h}h {m}m"
    if m > 0:
        return f"{m}m {s}s"
    return f"{s}s"

class GanttStrip(QWidget):
    segmentSelected = Signal(object)

    def __init__(self, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self._theme_name = current_theme_name()
        self._code: Optional[str] = None
        self._segments: List[Tuple[datetime, datetime, Optional[str]]] = []
        self._starts: List[datetime] = []
        self._start: Optional[datetime] = None
        self._end: Optional[datetime] = None
        self._placeholder: str = "No device selected"
        self._hover_x: Optional[float] = None
        self._hover_t: Optional[datetime] = None
        self._hover_seg: Optional[Tuple[datetime, datetime, Optional[str]]] = None
        self._selected_seg: Optional[Tuple[datetime, datetime, Optional[str]]] = None
        self._show_now_line: bool = True
        self._show_segment_labels: bool = True
        self._show_axis: bool = True
        self._margin_l, self._margin_r, self._margin_t, self._margin_b = 16, 16, 10, 34
        self._area = QRectF()
        self._bar_h = 0.0
        self._bar_y = 0.0
        self._ticks: List[datetime] = []
        self._geom_dirty = True
        self._cursor_pointing = False
        self._tooltip_last = ""
        theme_bus.changed.connect(self._on_theme_changed)
        self.setAttribute(Qt.WA_OpaquePaintEvent, True)
        self.setMouseTracking(True)
        self.setMinimumHeight(120)

    def sizeHint(self) -> QSize:
        return QSize(480, 160)

    def _on_theme_changed(self, name: str, _):
        self._theme_name = name
        self.update()

    def set_placeholder(self, text: Optional[str] = None):
        if text is not None:
            self._placeholder = text
        self._code = None
        self._segments = []
        self._starts = []
        self._start = None
        self._end = None
        self._hover_x = None
        self._hover_t = None
        self._hover_seg = None
        self._selected_seg = None
        self._geom_dirty = True
        self._tooltip_last = ""
        self.update()

    def set_segments(self, code: str, segments: List[Tuple[datetime, datetime, Optional[str]]], day_start: datetime, day_end: datetime):
        self._code = code
        self._segments = segments[:]
        self._segments.sort(key=lambda x: x[0])
        self._starts = [s for s, _, _ in self._segments]
        self._start = day_start
        self._end = day_end
        self._hover_x = None
        self._hover_t = None
        self._hover_seg = None
        self._selected_seg = None
        self._geom_dirty = True
        self._tooltip_last = ""
        self.update()

    def set_axis_visible(self, visible: bool):
        self._show_axis = bool(visible)
        if self._show_axis:
            self._margin_t, self._margin_b = 10, 34
        else:
            self._margin_t, self._margin_b = 8, 8
        self._geom_dirty = True
        self.update()

    def _time_to_x(self, t: datetime, left: float, right: float) -> float:
        if not self._start or not self._end:
            return left
        total = (self._end - self._start).total_seconds() or 1.0
        pos = (t - self._start).total_seconds()
        pos = max(0.0, min(total, pos))
        return left + (right - left) * (pos / total)

    def _x_to_time(self, x: float, left: float, right: float) -> Optional[datetime]:
        if not self._start or not self._end or right <= left:
            return None
        ratio = (x - left) / (right - left)
        ratio = max(0.0, min(1.0, ratio))
        delta = (self._end - self._start).total_seconds()
        return self._start + timedelta(seconds=delta * ratio)

    def _status_color(self, status: Optional[str]) -> QColor:
        colors = theme_colors(self._theme_name)
        hexc = colors["status"].get(status, colors["status"].get(None, "#00000000"))
        return QColor(str(hexc))

    def _find_segment_at(self, t: datetime) -> Optional[Tuple[datetime, datetime, Optional[str]]]:
        if not self._segments:
            return None
        i = bisect_right(self._starts, t) - 1
        if i >= 0:
            s, e, st = self._segments[i]
            if s <= t < e:
                return s, e, st
        return None

    def _hours_step(self, width_px: float) -> int:
        min_px = 64.0
        step = max(1, int(min_px / max(1.0, width_px / 24.0)))
        for cand in (1, 2, 3, 4, 6, 8, 12):
            if step <= cand:
                return cand
        return step

    def _aligned_hour_ticks(self, step_hours: int) -> List[datetime]:
        if not self._start or not self._end:
            return []
        start = self._start
        end = self._end
        first = start.replace(minute=0, second=0, microsecond=0)
        if first < start:
            first += timedelta(hours=1)
        ticks = []
        t = first
        step = timedelta(hours=step_hours)
        while t <= end:
            ticks.append(t)
            t += step
        return ticks

    @staticmethod
    def _luminance(c: QColor) -> float:
        r, g, b = c.redF(), c.greenF(), c.blueF()
        return 0.2126 * r + 0.7152 * g + 0.0722 * b

    def _contrast_text_on(self, bg: QColor, default: QColor) -> QColor:
        return QColor(Qt.black) if self._luminance(bg) > 0.5 else QColor(Qt.white)

    def _segment_rect(self, s: datetime, e: datetime, area: QRectF, bar_y: float, bar_h: float) -> QRectF:
        x1 = self._time_to_x(s, area.left(), area.right())
        x2 = self._time_to_x(e, area.left(), area.right())
        if x2 <= area.left() or x1 >= area.right():
            return QRectF()
        x1 = max(x1, area.left())
        x2 = min(x2, area.right())
        w = max(1.0, x2 - x1)
        return QRectF(x1, bar_y, w, bar_h)

    def _recalc_geometry(self):
        self._area = QRectF(self._margin_l, self._margin_t, self.width() - self._margin_l - self._margin_r, self.height() - self._margin_t - self._margin_b)
        self._bar_h = self._area.height()
        self._bar_y = self._area.top()
        self._ticks = self._aligned_hour_ticks(self._hours_step(self._area.width()))
        self._geom_dirty = False

    def _set_cursor_pointing(self, pointing: bool):
        if self._cursor_pointing != pointing:
            self._cursor_pointing = pointing
            self.setCursor(QCursor(Qt.PointingHandCursor) if pointing else QCursor(Qt.ArrowCursor))

    def mouseMoveEvent(self, event):
        if not self._start or not self._end:
            return super().mouseMoveEvent(event)
        if self._geom_dirty:
            self._recalc_geometry()
        x = event.position().x() if hasattr(event, "position") else float(event.pos().x())
        area = self._area
        if area.contains(QPointF(x, area.center().y())):
            t = self._x_to_time(x, area.left(), area.right())
            prev_seg = self._hover_seg
            self._hover_x = x
            self._hover_t = t
            seg = self._find_segment_at(t) if t else None
            self._hover_seg = seg
            self._set_cursor_pointing(bool(seg))
            if t:
                ts = t.strftime("%H:%M")
                if seg:
                    s, e, st = seg
                    dur = (e - s).total_seconds()
                    text = f"{ts}\nStatus: {st or 'Unknown'}\n{s.strftime('%H:%M')} → {e.strftime('%H:%M')}  ({_fmt_dur(dur)})"
                else:
                    text = f"{ts}\nNo data"
                if text != self._tooltip_last:
                    gp = event.globalPosition().toPoint() if hasattr(event, "globalPosition") else event.globalPos()
                    QToolTip.showText(gp, text, self)
                    self._tooltip_last = text
            if seg != prev_seg:
                self.update()
        else:
            self._hover_x = None
            self._hover_t = None
            self._hover_seg = None
            self._set_cursor_pointing(False)
            if self._tooltip_last:
                QToolTip.hideText()
                self._tooltip_last = ""
            self.update()
        super().mouseMoveEvent(event)

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton and self._hover_seg:
            self._selected_seg = self._hover_seg
            self.segmentSelected.emit(self._selected_seg)
            self.update()
        super().mousePressEvent(event)

    def leaveEvent(self, e):
        self._hover_x = None
        self._hover_t = None
        self._hover_seg = None
        self._set_cursor_pointing(False)
        if self._tooltip_last:
            QToolTip.hideText()
            self._tooltip_last = ""
        self.update()
        super().leaveEvent(e)

    def resizeEvent(self, e):
        super().resizeEvent(e)
        self._geom_dirty = True

    def paintEvent(self, _):
        p = QPainter(self)
        p.setRenderHint(QPainter.Antialiasing, True)
        colors = theme_colors(self._theme_name)
        bg = QColor(str(colors["surface"]))
        text_col = QColor(str(colors["text"]))
        grid_col = QColor(str(colors["text_alt"]))
        grid_col.setAlpha(90 if self._theme_name == "light" else 110)
        p.fillRect(self.rect(), bg)
        if self._geom_dirty:
            self._recalc_geometry()
        area = self._area
        p.setPen(QPen(grid_col, 1))
        p.drawRect(area)
        if not self._start or not self._end or not self._code:
            p.setPen(QPen(grid_col, 1))
            f = QFont(p.font())
            f.setPointSizeF(max(10.0, f.pointSizeF()))
            p.setFont(f)
            p.drawText(self.rect(), Qt.AlignCenter, self._placeholder)
            p.end()
            return
        if self._show_axis:
            step_ticks = self._ticks
            f_tick = QFont(p.font())
            f_tick.setPointSizeF(max(9.0, f_tick.pointSizeF() - 1))
            p.setFont(f_tick)
            for t in step_ticks:
                x = self._time_to_x(t, area.left(), area.right())
                is_major = t.hour in (0, 12)
                pen = QPen(grid_col, 1.5 if is_major else 1, Qt.DotLine)
                p.setPen(pen)
                p.drawLine(x, area.top(), x, area.bottom())
                p.setPen(QPen(text_col, 1))
                txt = t.strftime("%H:%M")
                p.drawText(QRectF(x - 24, self.height() - self._margin_b + 4, 48, self._margin_b - 6), Qt.AlignHCenter | Qt.AlignTop, txt)
        if self._show_now_line:
            try:
                now = datetime.now()
                if self._start <= now <= self._end:
                    x_now = self._time_to_x(now, area.left(), area.right())
                    p.setPen(QPen(QColor(str(colors["primary"])), 1.5))
                    p.drawLine(x_now, area.top(), x_now, area.bottom())
            except Exception:
                pass
        bar_h = self._bar_h
        bar_y = self._bar_y
        cache_color: dict[Optional[str], QColor] = {}
        def cstatus(st: Optional[str]) -> QColor:
            if st not in cache_color:
                cache_color[st] = self._status_color(st)
            return cache_color[st]
        for s, e, st in self._segments:
            rect = self._segment_rect(s, e, area, bar_y, bar_h)
            if rect.isNull():
                continue
            col = cstatus(st)
            if col.alpha() == 0:
                continue
            fill = QColor(col)
            fill.setAlpha(160 if self._theme_name == "light" else 180)
            p.fillRect(rect, QBrush(fill))
        def draw_outline(rect: QRectF, color: QColor, width: float, dash: Optional[Tuple[int, int]] = None):
            pen = QPen(color, width)
            if dash:
                pen.setStyle(Qt.CustomDashLine)
                pen.setDashPattern(list(dash))
            p.setPen(pen)
            p.setBrush(Qt.NoBrush)
            radius = min(6.0, rect.height() * 0.2)
            p.drawRoundedRect(rect.adjusted(0.5, 0.5, -0.5, -0.5), radius, radius)
        if self._selected_seg:
            s, e, st = self._selected_seg
            rect = self._segment_rect(s, e, area, bar_y, bar_h)
            if not rect.isNull():
                draw_outline(rect, QColor(str(colors["primary"])), 2.0)
        if self._hover_seg and self._hover_seg != self._selected_seg:
            s, e, st = self._hover_seg
            rect = self._segment_rect(s, e, area, bar_y, bar_h)
            if not rect.isNull():
                c = QColor(str(colors["primary"]))
                c.setAlpha(180)
                draw_outline(rect, c, 1.5, dash=(4, 3))
        label_cap = 200
        if self._show_segment_labels and len(self._segments) <= label_cap:
            f2 = QFont(p.font())
            f2.setPointSizeF(max(8.5, f2.pointSizeF() - 1.5))
            p.setFont(f2)
            for s, e, st in self._segments:
                rect = self._segment_rect(s, e, area, bar_y, bar_h)
                if rect.isNull() or rect.width() < 56:
                    continue
                col = cstatus(st)
                if col.alpha() == 0:
                    continue
                txt_color = self._contrast_text_on(col, text_col)
                p.setPen(QPen(txt_color, 1))
                label = (st or "").strip() or f"{s.strftime('%H:%M')} → {e.strftime('%H:%M')}"
                p.drawText(rect.adjusted(4, 0, -4, 0), Qt.AlignVCenter | Qt.AlignLeft, label)
        if self._hover_x is not None:
            p.setPen(QPen(QColor(str(colors["primary"])), 1))
            p.drawLine(self._hover_x, area.top(), self._hover_x, area.bottom())
        p.end()

class StatusSummaryBar(QWidget):
    def __init__(self, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self._theme_name = current_theme_name()
        self._segments: List[Tuple[datetime, datetime, Optional[str]]] = []
        self._start: Optional[datetime] = None
        self._end: Optional[datetime] = None
        self._rects: List[Tuple[QRectF, Optional[str], float]] = []
        self._tooltip_last = ""
        theme_bus.changed.connect(self._on_theme_changed)
        self.setAttribute(Qt.WA_OpaquePaintEvent, True)
        self.setMouseTracking(True)
        self.setMinimumHeight(44)

    def sizeHint(self) -> QSize:
        return QSize(400, 48)

    def _on_theme_changed(self, name: str, _):
        self._theme_name = name
        self.update()

    def set_segments(self, segments: List[Tuple[datetime, datetime, Optional[str]]], day_start: datetime, day_end: datetime):
        self._segments = segments[:]
        self._start = day_start
        self._end = day_end
        self._recalc_rects()
        self.update()

    def _status_color(self, status: Optional[str]) -> QColor:
        colors = theme_colors(self._theme_name)
        hexc = colors["status"].get(status, colors["status"].get(None, "#00000000"))
        return QColor(str(hexc))

    def _recalc_rects(self):
        self._rects.clear()
        if not self._start or not self._end or not self._segments:
            return
        total = (self._end - self._start).total_seconds()
        if total <= 0:
            return
        duration_map: dict[Optional[str], float] = {}
        for s, e, st in self._segments:
            a = max(s, self._start)
            b = min(e, self._end)
            if b > a:
                duration_map[st] = duration_map.get(st, 0.0) + (b - a).total_seconds()
        if not duration_map:
            return
        items = sorted(duration_map.items(), key=lambda kv: kv[1], reverse=True)
        start_x = 8.0
        end_x = max(start_x + 1.0, self.width() - 8.0)
        w = end_x - start_x
        h = max(1.0, self.height() - 16.0)
        for st, dur in items:
            percent = (dur / total) if total > 0 else 0.0
            rect_w = max(1.0, w * percent)
            r = QRectF(start_x, 8.0, rect_w, h)
            self._rects.append((r, st, percent))
            start_x += rect_w

    def resizeEvent(self, e):
        super().resizeEvent(e)
        self._recalc_rects()

    def mouseMoveEvent(self, event):
        if not self._rects:
            return super().mouseMoveEvent(event)
        pos = event.position() if hasattr(event, "position") else QPointF(event.pos())
        for r, st, pct in self._rects:
            if r.contains(pos):
                pct_txt = f"{pct*100:.1f}%"
                total = (self._end - self._start).total_seconds() if self._start and self._end else 0
                dur_txt = _fmt_dur(total * pct) if total else "-"
                text = f"Status: {st or 'Unknown'}\n{dur_txt}  ({pct_txt})"
                if text != self._tooltip_last:
                    gp = event.globalPosition().toPoint() if hasattr(event, "globalPosition") else event.globalPos()
                    QToolTip.showText(gp, text, self)
                    self._tooltip_last = text
                break
        super().mouseMoveEvent(event)

    def leaveEvent(self, e):
        if self._tooltip_last:
            QToolTip.hideText()
            self._tooltip_last = ""
        super().leaveEvent(e)

    def paintEvent(self, e):
        p = QPainter(self)
        p.setRenderHint(QPainter.Antialiasing, True)
        colors = theme_colors(self._theme_name)
        bg = QColor(str(colors["surface"]))
        grid_col = QColor(str(colors["text_alt"]))
        grid_col.setAlpha(90 if self._theme_name == "light" else 110)
        p.fillRect(self.rect(), bg)
        area = QRectF(8, 8, self.width() - 16, self.height() - 16)
        p.setPen(QPen(grid_col, 1))
        p.drawRect(area)
        if not self._rects:
            p.end()
            return
        cache_color: dict[Optional[str], QColor] = {}
        def cstatus(st: Optional[str]) -> QColor:
            if st not in cache_color:
                cache_color[st] = self._status_color(st)
            return cache_color[st]
        for r, st, pct in self._rects:
            col = cstatus(st)
            if col.alpha() == 0:
                continue
            fill = QColor(col)
            fill.setAlpha(170 if self._theme_name == "light" else 190)
            p.fillRect(r, QBrush(fill))
        p.end()

from __future__ import annotations
from typing import List, Any, Tuple
from PySide6.QtCore import QObject, Signal, QRunnable
from e_ui.utils import strip_accents

class IndexSignals(QObject):
    finished = Signal(object, tuple, tuple, int)
    error = Signal(str, int)

class IndexTask(QRunnable):
    def __init__(self, rows: List[List[Any]], cols: Tuple[int, ...], 
                 case_sensitive: bool, ignore_accents: bool, token: int, signals: IndexSignals):
        super().__init__()
        self.rows = rows
        self.cols = cols
        self.case_sensitive = case_sensitive
        self.ignore_accents = ignore_accents
        self.token = token
        self.signals = signals

    def run(self):
        try:
            out: List[List[str]] = []
            for r in self.rows:
                fields: List[str] = []
                for c in self.cols:
                    v = r[c] if c < len(r) else ""
                    s = v if isinstance(v, str) else ("" if v is None else str(v))
                    if not self.case_sensitive:
                        s = s.lower()
                    if self.ignore_accents:
                        s = strip_accents(s)
                    fields.append(s)
                out.append(fields)
            self.signals.finished.emit(out, self.cols, (self.case_sensitive, self.ignore_accents), self.token)
        except Exception as ex:
            self.signals.error.emit(str(ex), self.token)

from __future__ import annotations
from typing import Dict, Optional, List, Any, cast, Tuple
from datetime import datetime, timezone
from pathlib import Path
import json
import asyncio
from PySide6.QtCore import Qt, QPointF, Signal, QRectF
from PySide6.QtGui import QBrush, QColor, QPen, QPainter
from PySide6.QtWidgets import QGraphicsView, QGraphicsScene, QGraphicsRectItem, QGraphicsItemGroup, QGraphicsItem, QMenu, QStyleFactory, QGraphicsColorizeEffect, QGraphicsSimpleTextItem
from PySide6.QtSvgWidgets import QGraphicsSvgItem
from qasync import asyncSlot
from e_ui.theme import THEMES, ThemeColors, ThemeStatusMap

def _normalize_dt(dt: Optional[datetime]) -> Optional[datetime]:
    if dt is None:
        return None
    if dt.tzinfo is not None:
        return dt.astimezone(timezone.utc).replace(tzinfo=None)
    return dt

def _fmt_relative(dt: Optional[datetime]) -> str:
    dt = _normalize_dt(dt)
    if not dt:
        return "-"
    try:
        now = datetime.now()
        s = int((now - dt).total_seconds())
        if s < 60:
            return f"{s}s ago"
        m = s // 60
        if m < 60:
            return f"{m}m ago"
        h = m // 60
        if h < 24:
            return f"{h}h {m % 60}m ago"
        d = h // 24
        return f"{d}d {h % 24}h ago"
    except Exception:
        return "-"

class DeviceGroup(QGraphicsItemGroup):
    def __init__(self, path: str, code: str, name: str) -> None:
        super().__init__()
        self.code = code
        self.name = name
        self.current_status: Optional[str] = None
        self.latest_time: Optional[datetime] = None
        self.svg_item = QGraphicsSvgItem(path)
        self.svg_item.setCacheMode(QGraphicsItem.DeviceCoordinateCache)
        rect = self.svg_item.boundingRect()
        if rect.isEmpty():
            rect = QRectF(0, 0, 64, 64)
        padding = 10
        box_rect = rect.adjusted(-padding, -padding, padding, padding)
        self.box_item = QGraphicsRectItem(box_rect)
        self.box_item.setPen(Qt.NoPen)
        self.box_item.setBrush(Qt.NoBrush)
        self.border_item = QGraphicsRectItem(box_rect)
        self.border_item.setPen(Qt.NoPen)
        self.border_item.setBrush(Qt.NoBrush)
        self.badge_bg = QGraphicsRectItem()
        self.badge_bg.setPen(Qt.NoPen)
        self.badge_bg.setBrush(Qt.NoBrush)
        self.badge_bg.setVisible(False)
        self.text_item = QGraphicsSimpleTextItem("")
        self.text_item.setVisible(False)
        self.box_item.setZValue(0)
        self.svg_item.setZValue(1)
        self.badge_bg.setZValue(2)
        self.text_item.setZValue(3)
        self.border_item.setZValue(4)
        self.addToGroup(self.box_item)
        self.addToGroup(self.svg_item)
        self.addToGroup(self.badge_bg)
        self.addToGroup(self.text_item)
        self.addToGroup(self.border_item)
        self.setFlag(QGraphicsItem.ItemIsSelectable, True)
        self.setAcceptHoverEvents(True)
        self.current_theme = "light"
        self._status_color_func = None
        self._text_color = QColor("black")
        self._update_tooltip()

    def _lighter(self, c: QColor, factor: int = 160) -> QColor:
        return c.lighter(factor)

    def _update_tooltip(self):
        st = self.current_status or "Unknown"
        iso = self.latest_time.isoformat() if self.latest_time else "-"
        rel = _fmt_relative(self.latest_time)
        self.setToolTip(f"{self.code} • {self.name}\nStatus: {st}\nUpdated: {iso} ({rel})\nDouble-click: reset view\nRight-click: actions")

    def _update_border(self, hovered: bool = False):
        pen = QPen(Qt.NoPen)
        if self.isSelected():
            c = self._text_color if self._text_color.isValid() else QColor("white")
            pen = QPen(c, 2.2)
        elif hovered:
            fill = self.box_item.brush().color() if self.box_item.brush().style() != Qt.NoBrush else QColor(128, 128, 128, 80)
            pen = QPen(self._lighter(fill, 160), 2.0)
        self.border_item.setPen(pen)

    def hoverEnterEvent(self, event):
        self._update_border(hovered=True)
        super().hoverEnterEvent(event)

    def hoverLeaveEvent(self, event):
        self._update_border(hovered=False)
        super().hoverLeaveEvent(event)

    def itemChange(self, change, value):
        if change == QGraphicsItem.ItemSelectedHasChanged:
            self._update_border(hovered=False)
        return super().itemChange(change, value)

    def update_status(self, status: Optional[str], color: Optional[QColor], latest_time: Optional[datetime]) -> None:
        norm_time = _normalize_dt(latest_time)
        changed = (status != self.current_status) or (norm_time != self.latest_time)
        if not changed:
            return
        self.current_status = status
        self.latest_time = norm_time
        if color and isinstance(color, QColor) and color.isValid():
            prev_brush = self.box_item.brush()
            prev = prev_brush.color() if prev_brush.style() != Qt.NoBrush else None
            if not prev or prev != color:
                self.box_item.setBrush(QBrush(color))
        else:
            if self.box_item.brush().style() != Qt.NoBrush:
                self.box_item.setBrush(Qt.NoBrush)
        self._update_border(hovered=False)
        self._update_tooltip()

    def set_theme(self, theme: str, status_color_func, text_color: Optional[QColor] = None) -> None:
        self.current_theme = theme
        self._status_color_func = status_color_func
        if text_color is not None:
            self._text_color = text_color
        color = status_color_func(self.current_status) if status_color_func else None
        self.update_status(self.current_status, color, self.latest_time)

    def update_input_count(self, count: Optional[int], text_color: Optional[QColor] = None) -> None:
        if text_color is not None:
            self._text_color = text_color
        if count and count > 0:
            self.text_item.setText(str(count))
            self.text_item.setBrush(QBrush(self._text_color))
            rect = self.svg_item.boundingRect()
            tb = self.text_item.boundingRect()
            pad_x, pad_y = 6, 2
            w = tb.width() + 2 * pad_x
            h = tb.height() + 2 * pad_y
            x = rect.center().x() - w / 2
            y = rect.top() - h - 8
            bg = QColor(0, 0, 0, 170) if self.current_theme == "dark" else QColor(255, 255, 255, 200)
            self.badge_bg.setRect(QRectF(x, y, w, h))
            self.badge_bg.setBrush(QBrush(bg))
            self.text_item.setPos(x + pad_x, y + pad_y - 1)
            self.text_item.setVisible(True)
            self.badge_bg.setVisible(True)
        else:
            self.text_item.setVisible(False)
            self.badge_bg.setVisible(False)

class LayoutView(QGraphicsView):
    requestStatus = Signal(str)
    requestWip = Signal(str)
    requestEip = Signal(str)
    requestInput = Signal(str)
    deviceSelected = Signal(str)
    syncScaleRequested = Signal(float)
    MIN_SCALE = 0.2
    MAX_SCALE = 5.0

    def __init__(self, layout_json: str, tab_filter: str, status_service, theme: str) -> None:
        super().__init__()
        self.service = status_service
        self.tab_filter = tab_filter
        self.theme = theme.lower()
        self._scene = QGraphicsScene(self)
        self.setScene(self._scene)
        self.devices: Dict[str, DeviceGroup] = {}
        self.bg_item: Optional[QGraphicsSvgItem] = None
        self._current_scale = 1.0
        self.setRenderHints(self.renderHints() | QPainter.Antialiasing | QPainter.SmoothPixmapTransform | QPainter.TextAntialiasing)
        self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
        self.setResizeAnchor(QGraphicsView.AnchorViewCenter)
        self.setDragMode(QGraphicsView.NoDrag)
        self.setMouseTracking(True)
        self.setViewportUpdateMode(QGraphicsView.SmartViewportUpdate)
        self._load_layout(layout_json)

    def _status_color(self, v: Optional[str]) -> QColor:
        colors = cast(ThemeColors, THEMES.get(self.theme, THEMES["light"]))
        status_map = cast(ThemeStatusMap, colors["status"])
        return QColor(status_map.get(v, status_map.get(None, "#80808040")))

    def _text_color(self) -> QColor:
        colors = THEMES.get(self.theme, THEMES["light"])
        return QColor(colors["text"])

    def _to_datetime(self, v) -> Optional[datetime]:
        if isinstance(v, datetime):
            return _normalize_dt(v)
        if isinstance(v, str):
            try:
                dt = datetime.fromisoformat(v)
                return _normalize_dt(dt)
            except Exception:
                return None
        return None

    def _build_status_map(self, rows: List[Dict[str, Any]]) -> Dict[str, Tuple[Optional[str], Optional[datetime]]]:
        m: Dict[str, Tuple[Optional[str], Optional[datetime]]]= {}
        for r in rows:
            code = r.get("equip_code")
            if not code:
                continue
            status_code = r.get("equip_status")
            dt = self._to_datetime(r.get("as_of") or r.get("event_time"))
            m[code] = (status_code, dt)
        return m

    @asyncSlot()
    async def refresh_devices(self) -> None:
        try:
            codes = list(self.devices.keys())
            rows = await self.service.get_latest(codes)
            status_map = self._build_status_map(rows)
            for dev in self.devices.values():
                status_code, dt = status_map.get(dev.code, (None, None))
                dev.update_status(status_code, self._status_color(status_code), dt)
        except asyncio.CancelledError:
            return

    def apply_hot_data(self, status_rows: List[Dict[str, Any]]):
        status_map = self._build_status_map(status_rows)
        for dev in self.devices.values():
            status_code, dt = status_map.get(dev.code, (None, None))
            dev.update_status(status_code, self._status_color(status_code), dt)

    def apply_input_data(self, input_rows: List[Dict[str, Any]]):
        input_map: Dict[str, Optional[int]] = {}
        for r in input_rows:
            c = r.get("equip_code")
            if not c:
                continue
            mb = r.get("material_batch")
            input_map[c] = 1 if mb else None
        txt = self._text_color()
        for dev in self.devices.values():
            count = input_map.get(dev.code)
            dev.update_input_count(int(count) if count is not None else None, txt)

    def _load_layout(self, layout_json: str) -> None:
        p = Path(layout_json)
        base_dir = p.parent if p.parent.exists() else Path.cwd()
        colors = THEMES.get(self.theme, THEMES["light"])
        self.setBackgroundBrush(QBrush(QColor(colors["surface"])))
        data: dict = json.loads(p.read_text(encoding="utf-8")) if p.exists() else {}
        floor = data.get("floors", {}).get(self.tab_filter, {}) if data else {}
        self._load_background(base_dir, floor.get("background"))
        if self._scene.sceneRect().isEmpty():
            self._scene.setSceneRect(0, 0, 1600, 900)
        items = floor.get("devices") or floor.get("items") or []
        for it in items:
            code = str(it.get("code") or it.get("equip_code") or it.get("id") or "")
            name = str(it.get("name") or it.get("label") or code)
            img_decl = str(it.get("image") or f"{code}.svg")
            img_path = self._resolve_path(base_dir / "devices", img_decl, fallback=f"{code}.svg")
            dev = DeviceGroup(img_path, code, name)
            dev.set_theme(self.theme, self._status_color, self._text_color())
            x = float(it.get("x") or (it.get("pos") or {}).get("x") or 0)
            y = float(it.get("y") or (it.get("pos") or {}).get("y") or 0)
            dev.setPos(QPointF(x, y))
            self._scene.addItem(dev)
            self.devices[code] = dev
        self.fitInView(self._scene.sceneRect(), Qt.KeepAspectRatio)
        self._current_scale = self.transform().m11()

    def _load_background(self, base_dir: Path, bg_file: Optional[str]) -> None:
        if not bg_file:
            return
        path = self._resolve_path(base_dir, bg_file)
        if path:
            bg = QGraphicsSvgItem(path)
            bg.setZValue(0.0)
            bg.setCacheMode(QGraphicsItem.DeviceCoordinateCache)
            self.bg_item = bg
            self._scene.addItem(bg)
            self._scene.setSceneRect(bg.boundingRect())

    def _resolve_path(self, base_dir: Path, rel_or_abs: str, fallback: Optional[str] = None) -> str:
        q = Path(rel_or_abs)
        candidates = [q, Path("e_ui/assets/layout") / q, Path("e_ui/assets/devices") / q, base_dir / q]
        if fallback:
            candidates.append(Path("e_ui/assets/devices") / fallback)
            candidates.append(base_dir / fallback)
        for c in candidates:
            if c.exists():
                return str(c.resolve())
        return ""

    def mouseMoveEvent(self, event):
        sp = self.mapToScene(event.pos())
        items = self._scene.items(QRectF(sp.x() - 1, sp.y() - 1, 2, 2))
        self.setCursor(Qt.PointingHandCursor if any(isinstance(it, DeviceGroup) for it in items) else Qt.ArrowCursor)
        super().mouseMoveEvent(event)

    def mouseDoubleClickEvent(self, event) -> None:
        if event.button() == Qt.LeftButton:
            self.reset_view()
        super().mouseDoubleClickEvent(event)

    def reset_view(self) -> None:
        self.fitInView(self._scene.sceneRect(), Qt.KeepAspectRatio)
        self._current_scale = self.transform().m11()

    def mousePressEvent(self, event) -> None:
        if event.button() == Qt.LeftButton:
            sp = self.mapToScene(event.pos())
            items = self._scene.items(QRectF(sp.x() - 2, sp.y() - 2, 4, 4))
            target: Optional[DeviceGroup] = next((it for it in items if isinstance(it, DeviceGroup)), None)
            if target:
                for dev in self.devices.values():
                    dev.setSelected(False)
                target.setSelected(True)
                self.deviceSelected.emit(target.code)
            else:
                self.setDragMode(QGraphicsView.ScrollHandDrag)
        elif event.button() == Qt.MiddleButton:
            self.setDragMode(QGraphicsView.ScrollHandDrag)
        super().mousePressEvent(event)

    def mouseReleaseEvent(self, event):
        if event.button() in (Qt.LeftButton, Qt.MiddleButton):
            self.setDragMode(QGraphicsView.NoDrag)
        super().mouseReleaseEvent(event)

    def contextMenuEvent(self, event):
        sp = self.mapToScene(event.pos())
        items = self._scene.items(QRectF(sp.x() - 2, sp.y() - 2, 4, 4))
        target: Optional[DeviceGroup] = next((it for it in items if isinstance(it, DeviceGroup)), None)
        if target:
            self._show_device_menu(target, event.globalPos())

    def _show_device_menu(self, target: DeviceGroup, global_pos):
        m = QMenu(self)
        m.setStyle(QStyleFactory.create("Fusion"))
        a1 = m.addAction("📊 Status")
        a2 = m.addAction("📦 WIP")
        a3 = m.addAction("🌐 EIP")
        a5 = m.addAction("📥 Input")
        act = m.exec(global_pos)
        if act == a1:
            self.requestStatus.emit(target.code)
        elif act == a2:
            self.requestWip.emit(target.code)
        elif act == a3:
            self.requestEip.emit(target.code)
        elif act == a5:
            self.requestInput.emit(target.code)

    def wheelEvent(self, event) -> None:
        delta = event.angleDelta().y()
        if delta == 0:
            return
        factor = 1.15 if delta > 0 else 1 / 1.15
        new_scale = self._current_scale * factor
        new_scale = max(self.MIN_SCALE, min(self.MAX_SCALE, new_scale))
        factor = new_scale / self._current_scale
        self.scale(factor, factor)
        self._current_scale = new_scale
        self.syncScaleRequested.emit(self._current_scale)

    def apply_scale(self, scale_value: float) -> None:
        scale_value = max(self.MIN_SCALE, min(self.MAX_SCALE, scale_value))
        self.resetTransform()
        self.scale(scale_value, scale_value)
        self._current_scale = scale_value

    def fit_all(self) -> None:
        self.fitInView(self._scene.sceneRect(), Qt.KeepAspectRatio)
        self._current_scale = self.transform().m11()

    def fit_selected(self) -> None:
        sel = [it for it in self.devices.values() if it.isSelected()]
        if not sel:
            self.fit_all()
            return
        rect = sel[0].mapToScene(sel[0].childrenBoundingRect()).boundingRect()
        for it in sel[1:]:
            rect = rect.united(it.mapToScene(it.childrenBoundingRect()).boundingRect())
        if rect.isValid() and not rect.isEmpty():
            self.fitInView(rect.adjusted(-20, -20, 20, 20), Qt.KeepAspectRatio)
            self._current_scale = self.transform().m11()

    def set_theme(self, theme: str) -> None:
        self.theme = theme.lower()
        colors = THEMES.get(self.theme, THEMES["light"])
        self.setBackgroundBrush(QBrush(QColor(colors["surface"])))
        for dev in self.devices.values():
            dev.set_theme(self.theme, self._status_color, self._text_color())
        if self.bg_item:
            if self.theme == "dark":
                eff = QGraphicsColorizeEffect()
                eff.setColor(QColor("white"))
                self.bg_item.setGraphicsEffect(eff)
            else:
                self.bg_item.setGraphicsEffect(None)
        self.fit_all()

from __future__ import annotations
from PySide6.QtCore import Qt, QTimer, QSize
from PySide6.QtGui import QPainter, QColor, QPen
from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel

class Spinner(QWidget):
    def __init__(self, parent=None, size: int = 36, line_count: int = 12, 
                 line_length: int = 7, line_width: int = 3):
        super().__init__(parent)
        self._size = size
        self._count = line_count
        self._len = line_length
        self._w = line_width
        self._step = 0
        self._timer = QTimer(self)
        self._timer.timeout.connect(self._tick)
        self._interval_ms = 80
        self._timer.start(self._interval_ms)
        self.setAttribute(Qt.WA_TransparentForMouseEvents, True)
        self.setFixedSize(QSize(size, size))

    def _tick(self):
        self._step = (self._step + 1) % self._count
        self.update()

    def start(self):
        if not self._timer.isActive():
            self._timer.start(self._interval_ms)

    def stop(self):
        self._timer.stop()
        self._step = 0
        self.update()

    def paintEvent(self, _):
        p = QPainter(self)
        p.setRenderHint(QPainter.Antialiasing, True)
        p.translate(self.width() / 2, self.height() / 2)
        color = self.palette().highlight().color()
        radius = min(self.width(), self.height()) // 2 - self._len - 2
        for i in range(self._count):
            alpha = int(255 * (i + 1) / self._count)
            c = QColor(color)
            c.setAlpha(alpha)
            pen = QPen(c, self._w, Qt.SolidLine, Qt.RoundCap)
            p.setPen(pen)
            p.drawLine(0, -radius, 0, -(radius + self._len))
            p.rotate(360 / self._count)
        p.end()

class LoadingOverlay(QWidget):
    def __init__(self, parent: QWidget):
        super().__init__(parent)
        self.setAttribute(Qt.WA_StyledBackground, True)
        self.setStyleSheet("background: rgba(0,0,0,80);")
        self.setVisible(False)
        lay = QVBoxLayout(self)
        lay.setContentsMargins(0, 0, 0, 0)
        lay.setAlignment(Qt.AlignCenter)
        self._box = QWidget(self)
        self._box.setAttribute(Qt.WA_StyledBackground, True)
        self._box.setStyleSheet("background: rgba(255,255,255,0.92); border-radius: 12px; padding: 16px 24px;")
        box_lay = QVBoxLayout(self._box)
        box_lay.setContentsMargins(20, 16, 20, 16)
        box_lay.setSpacing(10)
        self._spinner = Spinner(self._box, size=40, line_length=8, line_width=3)
        self._label = QLabel("Đang tải...", self._box)
        self._label.setAlignment(Qt.AlignCenter)
        box_lay.addWidget(self._spinner, 0, Qt.AlignHCenter)
        box_lay.addWidget(self._label, 0, Qt.AlignHCenter)
        lay.addWidget(self._box, 0, Qt.AlignCenter)

    def start(self, text: str = "Đang tải dữ liệu..."):
        self._label.setText(text)
        self._spinner.start()
        self.resize(self.parentWidget().size())
        self.show()

    def set_text(self, text: str):
        self._label.setText(text)

    def stop(self):
        self._spinner.stop()
        self.hide()

from __future__ import annotations
import getpass, os
from datetime import datetime, timedelta, timezone
import json
import asyncio
import time
from pathlib import Path
from dataclasses import replace, dataclass
from typing import cast, List, Dict, Any, Optional
from PySide6.QtCore import Qt, QTimer, QSettings
from PySide6.QtGui import QAction, QKeySequence
from PySide6.QtWidgets import QApplication, QMainWindow, QTabWidget, QToolButton, QMenu, QWidget, QHBoxLayout, QLineEdit, QListWidget, QListWidgetItem, QVBoxLayout, QDialog, QLabel, QStatusBar, QStyleFactory, QWidgetAction, QComboBox, QSplitter
from qasync import asyncSlot
from a_core.configs.config import AppConfig, Theme
from d_application.services.full_service import FullLoaderService
from d_application.services.load_controller import LoadController
from e_ui.layout_view import LayoutView
from e_ui.dialogs import BaseTableDialog, StatusDialog, WipDialog, EipDialog, InputDialog
from e_ui.gantt import GanttStrip, StatusSummaryBar
from e_ui.theme import apply_theme, THEMES, apply_mica

def load_layout_codes(layout_path: str) -> list[str]:
    p = Path(layout_path)
    data = json.loads(p.read_text(encoding="utf-8"))
    codes: list[str] = []
    for floor in (data.get("floors") or {}).values():
        items = floor.get("items", []) or floor.get("devices", [])
        for item in items:
            code = str(item.get("id") or item.get("equip_code") or item.get("code") or "")
            if code:
                codes.append(code)
    return sorted(list(dict.fromkeys(codes)))

def _hex_to_rgba_str(s: str, alpha: float) -> str:
    s = s.strip()
    if s.startswith("#"):
        s = s[1:]
    if len(s) == 8:
        s = s[2:]
    if len(s) != 6:
        return "rgba(0,0,0,0.0)"
    r = int(s[0:2], 16)
    g = int(s[2:4], 16)
    b = int(s[4:6], 16)
    a = max(0.0, min(1.0, alpha))
    return f"rgba({r},{g},{b},{a:.3f})"

class CommandPalette(QDialog):
    def __init__(self, parent: QMainWindow, codes: list[str], handler) -> None:
        super().__init__(parent)
        self.setWindowFlags(Qt.WindowType.Dialog | Qt.WindowType.FramelessWindowHint)
        self.setModal(True)
        self.resize(440, 420)
        self.handler = handler
        lay = QVBoxLayout(self)
        lay.setContentsMargins(8, 8, 8, 8)
        self.search = QLineEdit(self)
        self.search.setPlaceholderText("Type equipment code or action… (e.g. 'status ABC123')")
        self.list_widget = QListWidget(self)
        self.list_widget.setAlternatingRowColors(True)
        for code in codes:
            self._add_item("status", "📊 Status", code)
            self._add_item("wip", "📦 WIP", code)
            self._add_item("eip", "🌐 EIP", code)
            self._add_item("input", "📥 Input", code)
        lay.addWidget(self.search)
        lay.addWidget(self.list_widget)
        self.search.textChanged.connect(self._filter)
        self.search.returnPressed.connect(self._activate_current)
        self.list_widget.itemActivated.connect(self._select)

    def _add_item(self, act: str, label: str, code: str):
        it = QListWidgetItem(f"{label} {code}", self.list_widget)
        it.setData(Qt.UserRole, (act, code))

    def showEvent(self, e):
        super().showEvent(e)
        self.search.setFocus()
        self._move_to_first()

    def keyPressEvent(self, e):
        if e.key() == Qt.Key_Escape:
            self.reject()
        else:
            super().keyPressEvent(e)

    def _filter(self, text: str):
        t = text.lower().strip()
        first_visible_row = -1
        for i in range(self.list_widget.count()):
            it = self.list_widget.item(i)
            is_vis = (t in it.text().lower()) if t else True
            it.setHidden(not is_vis)
            if is_vis and first_visible_row < 0:
                first_visible_row = i
        if first_visible_row >= 0:
            self.list_widget.setCurrentRow(first_visible_row)

    def _move_to_first(self):
        for i in range(self.list_widget.count()):
            it = self.list_widget.item(i)
            if not it.isHidden():
                self.list_widget.setCurrentRow(i)
                return

    def _activate_current(self):
        it = self.list_widget.currentItem()
        if it and not it.isHidden():
            self._select(it)

    def _select(self, item: QListWidgetItem):
        if item:
            data = item.data(Qt.UserRole) or (None, None)
            act, code = data
            if act and code:
                self.handler(act, code)
                self.accept()

class MiniToast(QLabel):
    def __init__(self, parent: QWidget, text: str, theme: str = "light"):
        super().__init__(parent)
        colors = THEMES.get(theme.lower(), THEMES["light"])
        accent = colors.get("primary", "#0F6CBD")
        bg = _hex_to_rgba_str(accent, 0.90) if theme.lower() == "light" else _hex_to_rgba_str(accent, 0.82)
        self.setText(text)
        self.setStyleSheet(f"background:{bg};color:white;padding:8px 12px;border-radius:10px;")
        self.setWindowFlags(Qt.WindowType.ToolTip)
        self.adjustSize()
        geo = parent.geometry()
        self.move(geo.center().x() - self.width() // 2, geo.bottom() - int(geo.height() * 0.12))
        self.show()
        QTimer.singleShot(2400, self.close)

DAYS_MAP = {
    "1d": 1,
    "1w": 7,
    "1m": 30,
    "3m": 90,
    "6m": 180,
}

@dataclass
class HistoryEntry:
    kind: str
    code: str
    dlg: BaseTableDialog
    task: Optional[asyncio.Task] = None
    token: int = 0

def _current_user() -> str:
    try:
        return getpass.getuser()
    except Exception:
        return os.environ.get("USERNAME") or os.environ.get("USER") or "Unknown"

class MainWindow(QMainWindow):
    SETTINGS_ORG = "MyCompany"
    SETTINGS_APP = "EquipMonitor"

    def __init__(self, cfg: AppConfig, full_service: FullLoaderService):
        super().__init__()
        self._settings = QSettings(self.SETTINGS_ORG, self.SETTINGS_APP)
        self.cfg = cfg
        self.full_service = full_service
        self.status_service = full_service.status_service
        self.input_service = full_service.input_service
        self.codes = load_layout_codes(cfg.layout_path)
        self.current_period_key = "1d"
        self._load_state()
        self.loader = LoadController(full_service, cfg.refresh_fast_ms or 30000, self.codes, quick_mode=True)
        self.loader.first_batch_ready.connect(self._handle_initial_data)
        self.loader.progress.connect(self._on_progress)
        user = _current_user()
        app = cfg.profile
        self.setWindowTitle(f"{app} | User: {user} | Design by IE")
        self.resize(1366, 860)
        self.tabs = QTabWidget(self)
        self.tabs.currentChanged.connect(self._on_tab_changed)
        self._gantt_tasks: dict[str, Optional[asyncio.Task]] = {"Electrode": None, "Assembly": None}
        self.setCentralWidget(self.tabs)
        self._selected_code: dict[str, Optional[str]] = {"Electrode": None, "Assembly": None}
        self._last_gantt_ts: dict[str, float] = {"Electrode": 0.0, "Assembly": 0.0}
        self._gantt_interval_sec: float = 1.0
        self._gantt_sync_ts: dict[str, float] = {"Electrode": 0.0, "Assembly": 0.0}
        self._gantt_sync_interval_sec: float = 1.0
        self._refresh_lock = asyncio.Lock()
        self._suppress_autofit_until = 0.0
        self._view_refresh_ms = getattr(cfg, "view_refresh_ms", 1500)
        self.settings_btn = QToolButton(self)
        self.settings_btn.setObjectName("settingsBtn")
        self.settings_btn.setText("⚙️")
        self.settings_btn.setToolButtonStyle(Qt.ToolButtonTextOnly)
        self.settings_btn.setFixedHeight(26)
        self.settings_btn.setPopupMode(QToolButton.ToolButtonPopupMode.InstantPopup)
        self.settings_btn.setMenu(self._build_settings_menu())
        cw = QWidget(self)
        cwl = QHBoxLayout(cw)
        cwl.setContentsMargins(0, 0, 0, 0)
        cwl.addWidget(self.settings_btn)
        self.tabs.setCornerWidget(cw, Qt.Corner.TopRightCorner)
        self._init_tabs()
        self.refresh_timer = QTimer(self)
        self.refresh_timer.setInterval(self._view_refresh_ms)
        self.refresh_timer.timeout.connect(self._refresh_device_views)
        self.refresh_timer.start()
        self.status = QStatusBar()
        self.setStatusBar(self.status)
        palette_act = QAction("Command Palette", self)
        palette_act.setShortcut(QKeySequence("Ctrl+P"))
        palette_act.triggered.connect(self._open_palette)
        self.addAction(palette_act)
        self._prog_status = 0
        self._prog_input = 0
        self._history_entries: list[HistoryEntry] = []
        self._restore_geometry()
        self._disable_text_shadows()
        QTimer.singleShot(0, self._fit_all_views)
        QTimer.singleShot(50, self._fit_all_views)

    def _on_progress(self, msg: str):
        self.status.showMessage(msg, 2000)

    def _progress_cb(self, src: str, n: int):
        if src == "status":
            self._prog_status = n
        elif src == "input":
            self._prog_input = n
        self.status.showMessage(f"⏳ Status={self._prog_status}, Input={self._prog_input}", 1000)

    def _handle_initial_data(self, data: list):
        if not data:
            return
        statuses = data[0].get("status", [])
        inputs = data[1].get("input", [])
        if hasattr(self, "view_electrode"):
            self.view_electrode.apply_hot_data(statuses)
            self.view_electrode.apply_input_data(inputs)
        if hasattr(self, "view_assembly"):
            self.view_assembly.apply_hot_data(statuses)
            self.view_assembly.apply_input_data(inputs)
        self.status.showMessage(f"Quick sync: {len(statuses)} status, {len(inputs)} input", 5000)

    def _maybe_refresh_gantt_current_tab(self):
        idx = self.tabs.currentIndex()
        tab = "Electrode" if idx == 0 else "Assembly"
        code = self._selected_code.get(tab)
        if not code:
            return
        now = time.monotonic()
        if now - self._last_gantt_ts[tab] < self._gantt_interval_sec:
            return
        self._last_gantt_ts[tab] = now
        self._update_gantt(tab, code)

    @asyncSlot()
    async def _refresh_device_views(self):
        if not self.isVisible() or self.isMinimized():
            return
        if self._refresh_lock.locked():
            return
        async with self._refresh_lock:
            try:
                idx = self.tabs.currentIndex()
                if hasattr(self, "view_electrode") and idx == 0:
                    await self.view_electrode.refresh_devices()
                elif hasattr(self, "view_assembly") and idx == 1:
                    await self.view_assembly.refresh_devices()
                if getattr(self, "_refresh_toggle", False):
                    other = self.view_assembly if idx == 0 else self.view_electrode
                    if other:
                        await other.refresh_devices()
                self._refresh_toggle = not getattr(self, "_refresh_toggle", False)
                self._maybe_refresh_gantt_current_tab()
            except asyncio.CancelledError:
                return
            except Exception as ex:
                self.status.showMessage(f"Refresh error: {ex}", 2000)

    def showEvent(self, e):
        super().showEvent(e)
        self._fit_all_views()
        QTimer.singleShot(0, lambda: apply_mica(self, dark=self.cfg.theme.value.lower() == "dark", kind="tabbed"))
        QTimer.singleShot(200, self.loader.start)

    def resizeEvent(self, e):
        super().resizeEvent(e)
        self._fit_current_view(throttled=True)

    def _on_tab_changed(self, _idx: int):
        self._fit_current_view(throttled=True)
        self._suppress_autofit(1.0)

    def _make_tab(self, floor_name: str) -> QWidget:
        container = QWidget(self)
        v = QVBoxLayout(container)
        v.setContentsMargins(0, 0, 0, 0)
        splitter = QSplitter(Qt.Vertical, container)
        splitter.setChildrenCollapsible(False)
        lv = LayoutView(self.cfg.layout_path, floor_name, self.status_service, self.cfg.theme.value)
        bottom = QWidget(container)
        bl = QVBoxLayout(bottom)
        bl.setContentsMargins(0, 0, 0, 0)
        gantt = GanttStrip(bottom)
        summary = StatusSummaryBar(bottom)
        H = 40
        summary.setFixedHeight(H)
        gantt.setFixedHeight(H)
        bl.addWidget(summary)
        bl.addWidget(gantt)
        splitter.addWidget(lv)
        splitter.addWidget(bottom)
        splitter.setStretchFactor(0, 4)
        splitter.setStretchFactor(1, 1)
        v.addWidget(splitter)
        QTimer.singleShot(0, lambda: splitter.setSizes([int(self.height() * 1), max(gantt.minimumHeight() + summary.height(), int(self.height() * 0.05))]))
        if floor_name == "Electrode":
            self.view_electrode = lv
            self.gantt_electrode = gantt
            self.summary_electrode = summary
            lv.deviceSelected.connect(lambda code: self._on_device_selected("Electrode", code))
            lv.requestStatus.connect(lambda code: self._on_device_selected("Electrode", code))
            lv.requestWip.connect(lambda code: self._on_device_selected("Electrode", code))
            lv.requestEip.connect(lambda code: self._on_device_selected("Electrode", code))
            lv.requestInput.connect(lambda code: self._on_device_selected("Electrode", code))
        else:
            self.view_assembly = lv
            self.gantt_assembly = gantt
            self.summary_assembly = summary
            lv.deviceSelected.connect(lambda code: self._on_device_selected("Assembly", code))
            lv.requestStatus.connect(lambda code: self._on_device_selected("Assembly", code))
            lv.requestWip.connect(lambda code: self._on_device_selected("Assembly", code))
            lv.requestEip.connect(lambda code: self._on_device_selected("Assembly", code))
            lv.requestInput.connect(lambda code: self._on_device_selected("Assembly", code))
        default_code = next(iter(lv.devices.keys()), None)
        if default_code:
            self._selected_code[floor_name] = default_code
            QTimer.singleShot(0, lambda: self._update_gantt(floor_name, default_code))
        else:
            gantt.set_placeholder()
        return container

    def _init_tabs(self):
        self.tabs.blockSignals(True)
        c1 = self._make_tab("Electrode")
        c2 = self._make_tab("Assembly")
        self.tabs.addTab(c1, "Electrode")
        self.tabs.addTab(c2, "Assembly")
        self.view_electrode.syncScaleRequested.connect(self.view_assembly.apply_scale)
        self.view_assembly.syncScaleRequested.connect(self.view_electrode.apply_scale)
        self.view_electrode.syncScaleRequested.connect(lambda _: self._suppress_autofit(1.5))
        self.view_assembly.syncScaleRequested.connect(lambda _: self._suppress_autofit(1.5))
        self._wire_layout(self.view_electrode)
        self._wire_layout(self.view_assembly)
        self.tabs.setCurrentIndex(0)
        self.tabs.blockSignals(False)

    def _on_device_selected(self, tab: str, code: str):
        self._selected_code[tab] = code
        self._update_gantt(tab, code)

    def _today_range(self) -> tuple[datetime, datetime]:
        now = datetime.utcnow()
        start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        return start, now

    def _parse_dt(self, v):
        if isinstance(v, datetime):
            dt = v
        elif isinstance(v, str):
            try:
                dt = datetime.fromisoformat(v)
            except Exception:
                try:
                    dt = datetime.strptime(v, "%Y-%m-%d %H:%M:%S")
                except Exception:
                    return None
        else:
            return None
        if dt.tzinfo is not None:
            dt = dt.astimezone(timezone.utc).replace(tzinfo=None)
        return dt

    def _build_segments(self, rows, start: datetime, clip_end: datetime, fallback_status: Optional[str] = None, fallback_time: Optional[datetime] = None):
        events = []
        for r in rows:
            dt = self._parse_dt(r.get("event_time"))
            if dt is not None:
                events.append((dt, r.get("equip_status")))
        events.sort(key=lambda x: x[0])
        initial_status = None
        for t, s in events:
            if t < start:
                initial_status = s
            else:
                break
        if initial_status is None:
            initial_status = fallback_status
        segs = []
        cur_t = start
        cur_status = initial_status
        for t, s in events:
            if t < start:
                continue
            if t > clip_end:
                break
            if cur_t < t:
                segs.append((cur_t, t, cur_status))
            cur_status = s
            cur_t = t
        if cur_t < clip_end:
            segs.append((cur_t, clip_end, cur_status))
        if not segs and fallback_status:
            start_seg = max(start, fallback_time) if isinstance(fallback_time, datetime) else start
            start_seg = min(start_seg, clip_end)
            if start_seg < clip_end:
                segs.append((start_seg, clip_end, fallback_status))
        return segs

    def _get_tab_widgets(self, tab: str) -> tuple[LayoutView, GanttStrip, StatusSummaryBar]:
        if tab == "Electrode":
            return self.view_electrode, self.gantt_electrode, self.summary_electrode
        return self.view_assembly, self.gantt_assembly, self.summary_assembly

    def _cancel_gantt_task(self, tab: str):
        t = self._gantt_tasks.get(tab)
        if t and not t.done():
            t.cancel()
        self._gantt_tasks[tab] = None

    def _period_range_for_gantt(self) -> tuple[datetime, datetime]:
        now = datetime.utcnow()
        start = now.replace(hour=0, minute=0, second=0, microsecond=0)
        end = start + timedelta(days=1)
        return start, end

    def _update_gantt(self, tab: str, code: Optional[str]):
        lv, gw, sb = self._get_tab_widgets(tab)
        self._cancel_gantt_task(tab)
        if not code:
            gw.set_placeholder()
            return
        async def run():
            try:
                s, e_axis = self._period_range_for_gantt()
                e_clip = min(e_axis, datetime.utcnow())
                q_start = s - timedelta(days=1)
                q_end = e_clip
                rows = await self.status_service.query_period([code], q_start, q_end)
                dev = lv.devices.get(code)
                fb_status = getattr(dev, "current_status", None)
                fb_time = getattr(dev, "latest_time", None)
                segs = self._build_segments(rows, s, e_clip, fallback_status=fb_status, fallback_time=fb_time)
                gw.set_segments(code, segs, s, e_axis)
                sb.set_segments(segs, s, e_clip)
                now_ts = time.monotonic()
                if now_ts - self._gantt_sync_ts[tab] > self._gantt_sync_interval_sec:
                    self._gantt_sync_ts[tab] = now_ts
                    try:
                        await self.status_service.sync_period([code], s, e_clip, progress_cb=None, backfill=True)
                        new_rows = await self.status_service.query_period([code], q_start, q_end)
                        segs2 = self._build_segments(new_rows, s, e_clip, fallback_status=fb_status, fallback_time=fb_time)
                        if code == self._selected_code.get(tab):
                            gw.set_segments(code, segs2, s, e_axis)
                            sb.set_segments(segs2, s, e_clip)
                    except Exception:
                        pass
            except asyncio.CancelledError:
                return
            except Exception:
                gw.set_placeholder("No data")
        task = asyncio.create_task(run())
        self._gantt_tasks[tab] = task

    def _wire_layout(self, lv: LayoutView):
        lv.requestStatus.connect(self._open_status)
        lv.requestWip.connect(self._open_wip)
        lv.requestEip.connect(self._open_eip)
        lv.requestInput.connect(self._open_input)

    def _row_action(self, label: str, widget: QWidget) -> QWidgetAction:
        w = QWidget(self)
        h = QHBoxLayout(w)
        h.setContentsMargins(10, 6, 10, 6)
        h.addWidget(QLabel(label))
        h.addStretch(1)
        h.addWidget(widget)
        act = QWidgetAction(self)
        act.setDefaultWidget(w)
        return act

    def _build_settings_menu(self) -> QMenu:
        m = QMenu(self)
        m.setStyle(QStyleFactory.create("Fusion"))
        self.cmb_period = QComboBox(m)
        self.cmb_period.addItem("1 day", "1d")
        self.cmb_period.addItem("1 week", "1w")
        self.cmb_period.addItem("1 month", "1m")
        self.cmb_period.addItem("3 months", "3m")
        self.cmb_period.addItem("6 months", "6m")
        idx = max(0, self.cmb_period.findData(self.current_period_key))
        self.cmb_period.setCurrentIndex(idx)
        self.cmb_period.currentIndexChanged.connect(self._on_period_changed)
        self.cmb_theme = QComboBox(m)
        self.cmb_theme.addItem("Light", "light")
        self.cmb_theme.addItem("Dark", "dark")
        t_idx = 1 if self.cfg.theme == Theme.DARK else 0
        self.cmb_theme.setCurrentIndex(t_idx)
        self.cmb_theme.currentIndexChanged.connect(self._on_theme_changed)
        m.addAction(self._row_action("History", self.cmb_period))
        m.addSeparator()
        m.addAction(self._row_action("Theme", self.cmb_theme))
        return m

    def _on_period_changed(self):
        key = self.cmb_period.currentData()
        if key in DAYS_MAP and key != self.current_period_key:
            self.current_period_key = key
            self._save_state()
            MiniToast(self, f"History: {self.cmb_period.currentText()}", self.cfg.theme.value)
            for entry in list(self._history_entries):
                if isinstance(entry.dlg, BaseTableDialog):
                    entry.dlg.set_period_key(self.current_period_key)
                self._restart_history_refresh(entry)

    def _on_theme_changed(self):
        val = self.cmb_theme.currentData()
        if isinstance(val, str):
            new = Theme.DARK if val == "dark" else Theme.LIGHT
            if new != self.cfg.theme:
                self.cfg = replace(self.cfg, theme=new)
                app = cast(QApplication, QApplication.instance())
                if app:
                    apply_theme(app, self.cfg.theme.value)
                if hasattr(self, "view_electrode"):
                    self.view_electrode.set_theme(self.cfg.theme.value)
                if hasattr(self, "view_assembly"):
                    self.view_assembly.set_theme(self.cfg.theme.value)
                apply_mica(self, dark=self.cfg.theme.value.lower() == "dark", kind="tabbed")
                self._disable_text_shadows()
                self._fit_all_views()
                self._save_state()

    def _period_range(self) -> tuple[datetime, datetime]:
        now = datetime.utcnow()
        today0 = now.replace(hour=0, minute=0, second=0, microsecond=0)
        key = self.current_period_key
        if key == "1d":
            start = today0
            end = now
        else:
            days = DAYS_MAP.get(key, 7)
            start = (today0 - timedelta(days=days))
            end = now
        return start, end

    def _register_history_dialog(self, kind: str, code: str, dlg: BaseTableDialog) -> HistoryEntry:
        entry = HistoryEntry(kind=kind, code=code, dlg=dlg)
        self._history_entries.append(entry)
        def _on_destroyed(_obj=None, e=entry):
            self._unregister_history_dialog(e)
        dlg.destroyed.connect(_on_destroyed)
        return entry

    def _unregister_history_dialog(self, entry: HistoryEntry):
        if entry.task and not entry.task.done():
            entry.task.cancel()
        try:
            self._history_entries.remove(entry)
        except ValueError:
            pass

    def _restart_history_refresh(self, entry: HistoryEntry):
        if not isinstance(entry.dlg, BaseTableDialog):
            return
        if not entry.dlg.isVisible():
            return
        if entry.task and not entry.task.done():
            entry.task.cancel()
        entry.token += 1
        tok = entry.token
        entry.task = asyncio.create_task(self._refresh_history(entry, tok))

    async def _refresh_history(self, entry: HistoryEntry, token: int, timeout_sec: int = 60):
        try:
            if not entry.dlg.isVisible():
                return
            s, e = self._period_range()
            if entry.kind in ("status", "wip", "eip"):
                rows = await self.status_service.query_period([entry.code], s, e)
                if token != entry.token or not entry.dlg.isVisible():
                    return
                if not rows:
                    entry.dlg.start_loading("Syncing status...")
                else:
                    entry.dlg.set_loading_text("Syncing status...")
                async def run_sync():
                    return await self.status_service.sync_period([entry.code], s, e, progress_cb=lambda src, n: entry.dlg.set_loading_text(f"Syncing {src}: {n} rows..."), backfill=True)
                try:
                    await asyncio.wait_for(run_sync(), timeout=timeout_sec)
                except asyncio.TimeoutError:
                    pass
                if token != entry.token or not entry.dlg.isVisible():
                    return
                new_rows = await self.status_service.query_period([entry.code], s, e)
                if token == entry.token and entry.dlg.isVisible():
                    entry.dlg.load_rows([[r.get("equip_code",""), r.get("equip_status",""), r.get("event_time","")] for r in new_rows])
                    entry.dlg.stop_loading()
            elif entry.kind == "input":
                rows = await self.input_service.query_period([entry.code], s, e)
                if token != entry.token or not entry.dlg.isVisible():
                    return
                if not rows:
                    entry.dlg.start_loading("Syncing input...")
                else:
                    entry.dlg.set_loading_text("Syncing input...")
                async def run_sync():
                    return await self.input_service.sync_period([entry.code], s, e, progress_cb=lambda src, n: entry.dlg.set_loading_text(f"Syncing {src}: {n} rows..."), backfill=True)
                try:
                    await asyncio.wait_for(run_sync(), timeout=timeout_sec)
                except asyncio.TimeoutError:
                    pass
                if token != entry.token or not entry.dlg.isVisible():
                    return
                new_rows = await self.input_service.query_period([entry.code], s, e)
                if token == entry.token and entry.dlg.isVisible():
                    entry.dlg.load_rows([[r.get("equip_code",""), r.get("material_batch",""), r.get("feeding_time","")] for r in new_rows])
                    entry.dlg.stop_loading()
        except asyncio.CancelledError:
            return
        except Exception as ex:
            if entry.dlg.isVisible():
                entry.dlg.set_loading_text(f"Error: {ex}")

    @asyncSlot()
    async def _open_status(self, code: str):
        s, e = self._period_range()
        rows = await self.status_service.query_period([code], s, e)
        dlg = StatusDialog(self, code, rows)
        dlg.set_period_key(self.current_period_key)
        dlg.setWindowModality(Qt.WindowModality.ApplicationModal)
        dlg.show()
        entry = self._register_history_dialog("status", code, dlg)
        self._restart_history_refresh(entry)

    @asyncSlot()
    async def _open_wip(self, code: str):
        s, e = self._period_range()
        rows = await self.status_service.query_period([code], s, e)
        dlg = WipDialog(self, code, rows)
        dlg.set_period_key(self.current_period_key)
        dlg.setWindowModality(Qt.WindowModality.ApplicationModal)
        dlg.show()
        entry = self._register_history_dialog("wip", code, dlg)
        self._restart_history_refresh(entry)

    @asyncSlot()
    async def _open_eip(self, code: str):
        s, e = self._period_range()
        rows = await self.status_service.query_period([code], s, e)
        dlg = EipDialog(self, code, rows)
        dlg.set_period_key(self.current_period_key)
        dlg.setWindowModality(Qt.WindowModality.ApplicationModal)
        dlg.show()
        entry = self._register_history_dialog("eip", code, dlg)
        self._restart_history_refresh(entry)

    @asyncSlot()
    async def _open_input(self, code: str):
        s, e = self._period_range()
        rows = await self.input_service.query_period([code], s, e)
        dlg = InputDialog(self, code, rows)
        dlg.setWindowModality(Qt.WindowModality.ApplicationModal)
        dlg.show()
        entry = self._register_history_dialog("input", code, dlg)
        self._restart_history_refresh(entry)

    def _disable_text_shadows(self):
        for w in self.findChildren(QWidget):
            w.setGraphicsEffect(None)

    def _suppress_autofit(self, seconds: float = 1.5):
        self._suppress_autofit_until = time.monotonic() + seconds

    def _fit_current_view(self, throttled: bool = False):
        if throttled and time.monotonic() < self._suppress_autofit_until:
            return
        idx = self.tabs.currentIndex()
        if idx == 0 and hasattr(self, "view_electrode"):
            self.view_electrode.fit_all()
        elif idx == 1 and hasattr(self, "view_assembly"):
            self.view_assembly.fit_all()

    def _fit_all_views(self):
        if hasattr(self, "view_electrode"):
            self.view_electrode.fit_all()
        if hasattr(self, "view_assembly"):
            self.view_assembly.fit_all()

    def _open_palette(self):
        dlg = CommandPalette(self, self.codes, self._execute_palette)
        dlg.exec()

    def _execute_palette(self, act: str, code: str):
        act = act.lower()
        if act == "status":
            asyncio.create_task(self._open_status(code))
        elif act == "wip":
            asyncio.create_task(self._open_wip(code))
        elif act == "eip":
            asyncio.create_task(self._open_eip(code))
        elif act == "input":
            asyncio.create_task(self._open_input(code))

    def _settings_key(self) -> str:
        return f"{self.cfg.profile}"

    def _save_state(self):
        s = self._settings
        s.beginGroup(self._settings_key())
        s.setValue("geometry", self.saveGeometry())
        s.setValue("theme", self.cfg.theme.value)
        s.endGroup()

    def _load_state(self):
        s = self._settings
        s.beginGroup(self._settings_key())
        s.endGroup()
        self.current_period_key = "1d"

    def _restore_geometry(self):
        s = self._settings
        s.beginGroup(self._settings_key())
        geo = s.value("geometry")
        s.endGroup()
        if geo is not None:
            self.restoreGeometry(geo)

    def closeEvent(self, event):
        try:
            self.loader.stop()
            self.refresh_timer.stop()
        except Exception:
            pass
        for entry in list(self._history_entries):
            self._unregister_history_dialog(entry)
        self._save_state()
        super().closeEvent(event)

from __future__ import annotations
from typing import Callable, Optional
from PySide6.QtCore import QModelIndex, QRegularExpression
from PySide6.QtGui import QPainter, QBrush
from PySide6.QtWidgets import QStyledItemDelegate

class CellDelegate(QStyledItemDelegate):
    def __init__(self, parent, get_regex: Callable[[], Optional[QRegularExpression]], 
                 should_highlight_col: Callable[[int], bool], 
                 get_cell_bg: Callable[[QModelIndex], Optional[QBrush]], 
                 highlight_brush: QBrush):
        super().__init__(parent)
        self._get_regex = get_regex
        self._should_highlight_col = should_highlight_col
        self._get_cell_bg = get_cell_bg
        self._highlight_brush = highlight_brush

    def set_highlight_brush(self, brush: QBrush):
        self._highlight_brush = brush

    def paint(self, painter: QPainter, option, index: QModelIndex):
        bg = self._get_cell_bg(index)
        if bg is not None:
            painter.save()
            painter.fillRect(option.rect, bg)
            painter.restore()
        regex = self._get_regex()
        text = index.data()
        if regex is not None and isinstance(text, str) and self._should_highlight_col(index.column()):
            if regex.match(text).hasMatch():
                painter.save()
                painter.fillRect(option.rect, self._highlight_brush)
                painter.restore()
        super().paint(painter, option, index)

from __future__ import annotations
from typing import List, Optional, Any
from PySide6.QtCore import Qt, QSortFilterProxyModel, QModelIndex, QAbstractTableModel, QRegularExpression
from PySide6.QtWidgets import QWidget
from e_ui.utils import strip_accents

class TableDataModel(QAbstractTableModel):
    def __init__(self, headers: List[str], rows: Optional[List[List[Any]]] = None, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self._headers = headers[:]
        self._rows: List[List[Any]] = rows[:] if rows else []

    def rowCount(self, parent: QModelIndex = QModelIndex()) -> int:
        return 0 if parent.isValid() else len(self._rows)

    def columnCount(self, parent: QModelIndex = QModelIndex()) -> int:
        return 0 if parent.isValid() else len(self._headers)

    def data(self, index: QModelIndex, role: int = Qt.DisplayRole) -> Any:
        if not index.isValid():
            return None
        if role in (Qt.DisplayRole, Qt.EditRole):
            r, c = index.row(), index.column()
            val = self._rows[r][c] if c < len(self._rows[r]) else ""
            return "" if val is None else str(val)
        return None

    def headerData(self, section: int, orientation: Qt.Orientation, role: int = Qt.DisplayRole) -> Any:
        if role != Qt.DisplayRole:
            return None
        if orientation == Qt.Horizontal:
            return self._headers[section] if 0 <= section < len(self._headers) else ""
        return section + 1

    def flags(self, index: QModelIndex) -> Qt.ItemFlags:
        if not index.isValid():
            return Qt.NoItemFlags
        return Qt.ItemIsSelectable | Qt.ItemIsEnabled

    def set_headers(self, headers: List[str]) -> None:
        self.beginResetModel()
        self._headers = headers[:]
        self.endResetModel()

    def set_rows(self, rows: List[List[Any]]) -> None:
        self.beginResetModel()
        self._rows = rows[:]
        self.endResetModel()

    def clear(self) -> None:
        self.set_rows([])

    def headers(self) -> List[str]:
        return self._headers[:]

class ExtendedSortFilterProxyModel(QSortFilterProxyModel):
    def __init__(self, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self._text: str = ""
        self._is_regex: bool = False
        self._exact: bool = False
        self._case_sensitive: bool = False
        self._ignore_accents: bool = False
        self._logic_and: bool = False
        self._filter_key_col: int = -1
        self._highlight_re: Optional[QRegularExpression] = None
        self._tokens: List[str] = []
        self._row_fields_cache: List[Optional[List[str]]] = []
        self._cache_cols_key: Optional[tuple[int, ...]] = None
        self._cache_norm_key: Optional[tuple[bool, bool]] = None
        self._bound_model = None

    def setSourceModel(self, sourceModel):
        super().setSourceModel(sourceModel)
        self._bind_source_signals()
        self._reset_cache()
        self.invalidateFilter()

    def _bind_source_signals(self):
        if self._bound_model is not None:
            try:
                self._bound_model.modelReset.disconnect(self._on_source_reset)
                self._bound_model.layoutChanged.disconnect(self._on_source_reset)
                self._bound_model.rowsInserted.disconnect(self._on_rows_changed)
                self._bound_model.rowsRemoved.disconnect(self._on_rows_changed)
                self._bound_model.dataChanged.disconnect(self._on_source_data_changed)
            except Exception:
                pass
        m = self.sourceModel()
        self._bound_model = m
        if m is not None:
            m.modelReset.connect(self._on_source_reset)
            m.layoutChanged.connect(self._on_source_reset)
            m.rowsInserted.connect(self._on_rows_changed)
            m.rowsRemoved.connect(self._on_rows_changed)
            m.dataChanged.connect(self._on_source_data_changed)

    def _on_source_reset(self):
        self._reset_cache()
        self.invalidateFilter()

    def _on_rows_changed(self, *args):
        self._resize_cache()
        self.invalidateFilter()

    def _on_source_data_changed(self, *args):
        self._reset_cache()
        self.invalidateFilter()

    def _resize_cache(self):
        m = self.sourceModel()
        if m is None:
            self._row_fields_cache = []
            return
        n = m.rowCount()
        cur = len(self._row_fields_cache)
        if n == cur:
            return
        if n > cur:
            self._row_fields_cache.extend([None] * (n - cur))
        else:
            self._row_fields_cache = self._row_fields_cache[:n]

    def _reset_cache(self):
        m = self.sourceModel()
        n = m.rowCount() if m else 0
        self._row_fields_cache = [None] * n
        self._cache_cols_key = None
        self._cache_norm_key = None

    def set_prebuilt_cache(self, cache: List[List[str]], cols_key: tuple[int, ...], norm_key: tuple[bool, bool]):
        m = self.sourceModel()
        if m is None:
            return
        if len(cache) != m.rowCount():
            return
        self._row_fields_cache = [fields[:] for fields in cache]
        self._cache_cols_key = cols_key
        self._cache_norm_key = norm_key
        self.invalidateFilter()

    def setFilterParams(self, text: str, is_regex: bool, exact: bool, case_sensitive: bool, ignore_accents: bool, logic_and: bool, key_col: int):
        self._text = text or ""
        self._is_regex = is_regex
        self._exact = exact
        self._case_sensitive = case_sensitive
        self._ignore_accents = ignore_accents
        self._logic_and = logic_and
        self._filter_key_col = int(key_col) if isinstance(key_col, int) else -1
        self._tokens = [t for t in self._text.split() if t]
        self._highlight_re = self._make_highlight_regex()
        self.setFilterRegularExpression(self._highlight_re or QRegularExpression())
        self._reset_cache()
        self.invalidateFilter()

    def highlight_regex(self) -> Optional[QRegularExpression]:
        return self._highlight_re

    def _norm(self, s: str) -> str:
        if s is None:
            s = ""
        s = s if self._case_sensitive else s.lower()
        if self._ignore_accents:
            s = strip_accents(s)
        return s

    def _make_highlight_regex(self) -> Optional[QRegularExpression]:
        if not self._text:
            return None
        if self._is_regex:
            pattern = self._text
            if self._exact and not pattern.startswith("^"):
                pattern = f"^{pattern}$"
            opts = QRegularExpression.CaseInsensitiveOption if not self._case_sensitive else QRegularExpression.NoPatternOption
            return QRegularExpression(pattern, opts)
        tokens = [t for t in self._text.split() if t]
        if not tokens:
            return None
        pat = "|".join(QRegularExpression.escape(t) for t in tokens)
        opts = QRegularExpression.CaseInsensitiveOption if not self._case_sensitive else QRegularExpression.NoPatternOption
        return QRegularExpression(pat, opts)

    def _selected_columns(self, model) -> List[int]:
        if self._filter_key_col is None or self._filter_key_col < 0:
            return list(range(model.columnCount()))
        return [self._filter_key_col]

    def _ensure_row_cache(self, row: int):
        m = self.sourceModel()
        if m is None:
            return
        cols = tuple(self._selected_columns(m))
        norm_key = (self._case_sensitive, self._ignore_accents)
        if self._cache_cols_key != cols or self._cache_norm_key != norm_key:
            self._row_fields_cache = [None] * m.rowCount()
            self._cache_cols_key = cols
            self._cache_norm_key = norm_key
        if 0 <= row < len(self._row_fields_cache) and self._row_fields_cache[row] is None:
            fields: List[str] = []
            for c in cols:
                idx = m.index(row, c)
                val = idx.data() or ""
                s = val if isinstance(val, str) else str(val)
                fields.append(self._norm(s))
            self._row_fields_cache[row] = fields

    def filterAcceptsRow(self, source_row: int, source_parent: QModelIndex) -> bool:
        if not self._text:
            return True
        m = self.sourceModel()
        if m is None:
            return True
        if self._is_regex:
            rexp = self._highlight_re
            if rexp is None:
                return True
            if self._filter_key_col is None or self._filter_key_col < 0:
                for c in range(m.columnCount()):
                    idx = m.index(source_row, c)
                    val = idx.data() or ""
                    s = val if isinstance(val, str) else str(val)
                    if rexp.match(s).hasMatch():
                        return True
                return False
            idx = m.index(source_row, self._filter_key_col)
            val = idx.data() or ""
            s = val if isinstance(val, str) else str(val)
            return rexp.match(s).hasMatch()
        self._ensure_row_cache(source_row)
        fields = self._row_fields_cache[source_row] or []
        if not self._tokens:
            return True
        tokens_norm = [self._norm(t) for t in self._tokens]
        def token_in_fields(tok: str) -> bool:
            if self._exact:
                return any(tok == f for f in fields)
            return any(tok in f for f in fields)
        if self._logic_and:
            return all(token_in_fields(t) for t in tokens_norm)
        return any(token_in_fields(t) for t in tokens_norm)

    def lessThan(self, left: QModelIndex, right: QModelIndex) -> bool:
        lv = self.sourceModel().data(left, Qt.DisplayRole)
        rv = self.sourceModel().data(right, Qt.DisplayRole)
        try:
            lf = float(str(lv).replace(",", ""))
            rf = float(str(rv).replace(",", ""))
            return lf < rf
        except Exception:
            pass
        ls = str(lv) if lv is not None else ""
        rs = str(rv) if rv is not None else ""
        ls = self._norm(ls)
        rs = self._norm(rs)
        return ls < rs

from __future__ import annotations
from typing import Dict, Union, Optional, cast
import sys
from PySide6.QtCore import QObject, Signal
from PySide6.QtGui import QColor, QPalette
from PySide6.QtWidgets import QApplication, QStyleFactory

ThemeStatusMap = Dict[Optional[str], str]
ThemeColors = Dict[str, Union[str, ThemeStatusMap]]
ACCENT_DEFAULT = "#0F6CBD"

def _win_accent_hex() -> Optional[str]:
    if sys.platform != "win32":
        return None
    try:
        import winreg
        with winreg.OpenKey(winreg.HKEY_CURRENT_USER, r"Software\Microsoft\Windows\DWM") as k:
            val, _ = winreg.QueryValueEx(k, "AccentColor")
            r = val & 0xFF
            g = (val >> 8) & 0xFF
            b = (val >> 16) & 0xFF
            return f"#{r:02x}{g:02x}{b:02x}"
    except Exception:
        return None

def _edge_colors(mode: str) -> ThemeColors:
    accent = _win_accent_hex() or ACCENT_DEFAULT
    if mode == "dark":
        return {
            "background": "#0f1115",
            "surface": "#1c1f24",
            "surface_alt": "transparent",
            "text": "#f3f4f6",
            "text_alt": "#a3aab2",
            "primary": accent,
            "menu_border": "#2a2f36",
            "hover": "#232830",
            "button": "#242a31",
            "status": {
                "1": "#15ff00",
                "2": "#e2e2e1",
                "3": "#ff0000",
                "4": "#0066ff",
                "5": "#fffb00",
                None: "#00000000"
            },
        }
    return {
        "background": "#f6f7f9",
        "surface": "#ffffff",
        "surface_alt": "#f7f8fa",
        "text": "#1a1d21",
        "text_alt": "#5f6670",
        "primary": accent,
        "menu_border": "#e5e7eb",
        "hover": "#eef3fb",
        "button": "#f3f4f6",
        "status": {
            "1": "#15ff00",
            "2": "#e2e2e1",
            "3": "#ff0000",
            "4": "#0066ff",
            "5": "#fffb00",
            None: "#00000000"
        },
    }

THEMES: Dict[str, ThemeColors] = {
    "dark": _edge_colors("dark"),
    "light": _edge_colors("light"),
}

def make_palette(colors: ThemeColors) -> QPalette:
    bg = cast(str, colors["background"])
    text = cast(str, colors["text"])
    surface = cast(str, colors["surface"])
    surface_alt = cast(str, colors["surface_alt"])
    button = cast(str, colors["button"])
    primary = cast(str, colors["primary"])
    text_alt = cast(str, colors["text_alt"])
    menu_border = cast(str, colors["menu_border"])
    p = QPalette()
    p.setColor(QPalette.ColorRole.Window, QColor(bg))
    p.setColor(QPalette.ColorRole.WindowText, QColor(text))
    p.setColor(QPalette.ColorRole.Base, QColor(surface))
    p.setColor(QPalette.ColorRole.AlternateBase, QColor(surface_alt))
    p.setColor(QPalette.ColorRole.ToolTipBase, QColor(surface))
    p.setColor(QPalette.ColorRole.ToolTipText, QColor(text))
    p.setColor(QPalette.ColorRole.Text, QColor(text))
    p.setColor(QPalette.ColorRole.Button, QColor(button))
    p.setColor(QPalette.ColorRole.ButtonText, QColor(text))
    p.setColor(QPalette.ColorRole.Highlight, QColor(primary))
    p.setColor(QPalette.ColorRole.HighlightedText, QColor(text))
    p.setColor(QPalette.ColorRole.PlaceholderText, QColor(text_alt))
    p.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.Text, QColor(text_alt))
    p.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.ButtonText, QColor(text_alt))
    p.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.WindowText, QColor(text_alt))
    p.setColor(QPalette.ColorGroup.Disabled, QPalette.ColorRole.Base, QColor(surface_alt))
    return p

def _hex_to_rgba(s: str, alpha: float) -> str:
    s = s.strip()
    if s.startswith("#"):
        s = s[1:]
    if len(s) == 8:
        s = s[2:]
    if len(s) != 6:
        return "rgba(0,0,0,0.0)"
    r = int(s[0:2], 16)
    g = int(s[2:4], 16)
    b = int(s[4:6], 16)
    a = max(0.0, min(1.0, alpha))
    return f"rgba({r},{g},{b},{a:.3f})"

def make_stylesheet(colors: ThemeColors) -> str:
    text_alt = cast(str, colors["text_alt"])
    accent = cast(str, colors["primary"])
    accent_08 = _hex_to_rgba(accent, 0.08)
    accent_14 = _hex_to_rgba(accent, 0.14)
    accent_20 = _hex_to_rgba(accent, 0.20)
    accent_28 = _hex_to_rgba(accent, 0.28)
    return f"""
    * {{
        font-family: "Segoe UI Variable", "Segoe UI", "Inter", "Arial";
        font-size: 13px;
        selection-background-color: {accent_28};
    }}
    QMainWindow {{
        background: {cast(str, colors['background'])};
    }}
    QStatusBar {{
        background: {cast(str, colors['surface'])};
        color: {text_alt};
        border-top: 1px solid {cast(str, colors['menu_border'])};
    }}
    QTabBar::tab {{
        background: transparent;
        color: {text_alt};
        padding: 6px 12px;
        min-height: 26px;
        border: none;
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
        margin-right: 4px;
    }}
    QTabBar::tab:hover {{
        background: {cast(str, colors['hover'])};
        color: {cast(str, colors['text'])};
    }}
    QTabBar::tab:selected {{
        background: {cast(str, colors['surface'])};
        color: {cast(str, colors['text'])};
        margin-bottom: -2px;
        border-bottom: 2px solid {cast(str, colors['primary'])};
    }}
    QTabWidget::pane {{
        background: {cast(str, colors['surface'])};
        border: 1px solid {cast(str, colors['menu_border'])};
        border-top: 0px;
        top: -2px;
        border-radius: 8px;
    }}
    QPushButton {{
        border-radius: 8px;
        padding: 6px 14px;
        background: {cast(str, colors['button'])};
        color: {cast(str, colors['text'])};
        border: 1px solid {cast(str, colors['menu_border'])};
    }}
    QPushButton:hover {{
        background: {cast(str, colors['hover'])};
    }}
    QPushButton:focus {{
        outline: none;
        border: 1px solid {cast(str, colors['primary'])};
        background: {accent_08};
    }}
    QToolButton {{
        border: none;
        background: transparent;
        padding: 4px 8px;
        border-radius: 6px;
        color: {cast(str, colors['text'])};
    }}
    QToolButton:hover {{
        background: {accent_08};
    }}
    QToolButton:pressed {{
        background: {accent_14};
    }}
    QToolButton#settingsBtn {{
        min-height: 26px;
        min-width: 32px;
        font-size: 16px;
        padding: 0 8px;
        margin-top: 0px;
        border-radius: 6px;
    }}
    QLineEdit, QComboBox, QSpinBox, QDoubleSpinBox, QDateTimeEdit {{
        color: {cast(str, colors['text'])};
        background: {cast(str, colors['surface'])};
        border: 1px solid {cast(str, colors['menu_border'])};
        padding: 6px 8px;
        border-radius: 8px;
    }}
    QLineEdit::placeholder {{
        color: {text_alt};
    }}
    QLineEdit:focus, QComboBox:focus, QSpinBox:focus, QDoubleSpinBox:focus, QDateTimeEdit:focus {{
        border: 1px solid {cast(str, colors['primary'])};
        background: {accent_08};
    }}
    QMenu {{
        background: {cast(str, colors['surface'])};
        color: {cast(str, colors['text'])};
        border: 1px solid {cast(str, colors['menu_border'])};
        border-radius: 8px;
        padding: 6px 2px;
    }}
    QMenu::item {{
        padding: 6px 12px;
        border-radius: 6px;
        color: {cast(str, colors['text'])};
    }}
    QMenu::item:selected {{
        background: {accent_14};
        color: {cast(str, colors['text'])};
    }}
    QMenu::item:disabled {{
        color: {text_alt};
        background: transparent;
    }}
    QGraphicsView {{
        background: {cast(str, colors['surface'])};
        border: 0;
    }}
    QHeaderView::section {{
        background: {cast(str, colors['surface'])};
        color: {cast(str, colors['text'])};
        border: none;
        border-bottom: 1px solid {cast(str, colors['menu_border'])};
        padding: 6px 8px;
    }}
    QTableView {{
        gridline-color: {cast(str, colors['menu_border'])};
        selection-background-color: {accent_20};
        selection-color: {cast(str, colors['text'])};
        alternate-background-color: {cast(str, colors['surface_alt'])};
    }}
    QScrollBar:vertical {{
        background: transparent;
        width: 10px;
        margin: 2px;
        border: none;
    }}
    QScrollBar::handle:vertical {{
        background: {_hex_to_rgba(text_alt, 0.35)};
        border-radius: 5px;
        min-height: 30px;
    }}
    QScrollBar::handle:vertical:hover {{
        background: {_hex_to_rgba(text_alt, 0.55)};
    }}
    QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
        height: 0px;
        border: none; background: none;
    }}
    QScrollBar:horizontal {{
        background: transparent;
        height: 10px;
        margin: 2px;
        border: none;
    }}
    QScrollBar::handle:horizontal {{
        background: {_hex_to_rgba(text_alt, 0.35)};
        border-radius: 5px;
        min-width: 30px;
    }}
    QScrollBar::handle:horizontal:hover {{
        background: {_hex_to_rgba(text_alt, 0.55)};
    }}
    QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {{
        width: 0px;
        border: none; background: none;
    }}
    QToolTip {{
        background: {cast(str, colors['surface'])};
        color: {cast(str, colors['text'])};
        border: 1px solid {cast(str, colors['menu_border'])};
        padding: 4px 8px;
        border-radius: 6px;
    }}
    """

class ThemeBus(QObject):
    changed = Signal(str, object)

theme_bus = ThemeBus()
_current_theme_name = "light"

def apply_theme(app: QApplication, theme: str) -> None:
    global _current_theme_name
    theme = (theme or "light").lower()
    colors = THEMES.get(theme, THEMES["light"])
    app.setStyle(QStyleFactory.create("Fusion"))
    app.setPalette(make_palette(colors))
    app.setStyleSheet(make_stylesheet(colors))
    _current_theme_name = theme
    theme_bus.changed.emit(theme, colors)

def apply_mica(widget, dark: bool = False, kind: str = "tabbed") -> bool:
    if sys.platform != "win32":
        return False
    try:
        import ctypes
        from ctypes import wintypes
        hwnd = int(widget.winId())
        dwmapi = ctypes.WinDLL("dwmapi")
        DWMWA_USE_IMMERSIVE_DARK_MODE = 20
        val = ctypes.c_int(1 if dark else 0)
        dwmapi.DwmSetWindowAttribute(wintypes.HWND(hwnd), ctypes.c_uint(DWMWA_USE_IMMERSIVE_DARK_MODE), ctypes.byref(val), ctypes.sizeof(val))
        DWMWA_SYSTEMBACKDROP_TYPE = 38
        kinds = {"main": 2, "transient": 3, "tabbed": 4}
        backdrop = ctypes.c_int(kinds.get(kind, 4))
        res = dwmapi.DwmSetWindowAttribute(wintypes.HWND(hwnd), ctypes.c_uint(DWMWA_SYSTEMBACKDROP_TYPE), ctypes.byref(backdrop), ctypes.sizeof(backdrop))
        DWMWA_WINDOW_CORNER_PREFERENCE = 33
        DWMWCP_ROUND = 2
        corner = ctypes.c_int(DWMWCP_ROUND)
        dwmapi.DwmSetWindowAttribute(wintypes.HWND(hwnd), ctypes.c_uint(DWMWA_WINDOW_CORNER_PREFERENCE), ctypes.byref(corner), ctypes.sizeof(corner))
        return res == 0
    except Exception:
        return False

def current_theme_name() -> str:
    return _current_theme_name

def theme_colors(name: Optional[str] = None) -> ThemeColors:
    n = (name or _current_theme_name).lower()
    return THEMES.get(n, THEMES["light"])

from __future__ import annotations
from typing import Any, Optional
import unicodedata
from datetime import datetime, timezone

def strip_accents(text: str) -> str:
    return "".join(ch for ch in unicodedata.normalize("NFD", text) if not unicodedata.combining(ch))

def to_datetime(v: Any) -> Optional[datetime]:
    dt: Optional[datetime] = None
    if isinstance(v, datetime):
        dt = v
    elif isinstance(v, str):
        try:
            dt = datetime.fromisoformat(v)
        except Exception:
            try:
                dt = datetime.strptime(v, "%Y-%m-%d %H:%M:%S")
            except Exception:
                return None
    else:
        return None
    if dt.tzinfo is not None:
        dt = dt.astimezone(timezone.utc).replace(tzinfo=None)
    return dt

from __future__ import annotations
import sys, asyncio, logging
from typing import cast
from PySide6.QtWidgets import QApplication, QMessageBox
from qasync import QEventLoop
from a_core.configs.config import init_config_system, get_config, register_config_callback, AppConfig, shutdown_config_system
from e_ui.main_window import MainWindow
from e_ui.theme import apply_theme
from di import build_container

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

async def setup_app(app: QApplication) -> tuple[MainWindow, object]:
    try:
        init_config_system()
        cfg: AppConfig = get_config()
    except Exception as ex:
        QMessageBox.critical(None, "Startup Error", f"Config error:\n{ex}")
        sys.exit(1)
    register_config_callback(lambda new_cfg: apply_theme(app, new_cfg.theme.value))
    full_service, dbm = build_container()
    try:
        await dbm.initialize()
    except Exception as ex:
        QMessageBox.critical(None, "DB Init Error", f"Database init failed:\n{ex}")
        sys.exit(1)
    await full_service.initialize()
    apply_theme(app, cfg.theme.value)
    window = MainWindow(cfg, full_service)
    window.show()
    return window, dbm

def main():
    app = QApplication.instance() or QApplication(sys.argv)
    app = cast(QApplication, app)
    loop = QEventLoop(app)
    asyncio.set_event_loop(loop)
    async def _shutdown(dbm):
        try:
            tasks = [t for t in asyncio.all_tasks(loop) if t is not asyncio.current_task(loop)]
            for t in tasks:
                t.cancel()
            if tasks:
                await asyncio.gather(*tasks, return_exceptions=True)
        finally:
            try:
                await dbm.dispose_all()
            except Exception:
                pass
            try:
                shutdown_config_system()
            except Exception:
                pass
            loop.stop()
    with loop:
        try:
            window, db = loop.run_until_complete(setup_app(app))
            app.aboutToQuit.connect(lambda: asyncio.ensure_future(_shutdown(db)))
            loop.create_task(window.full_service.full_sync())
            loop.run_forever()
            sys.exit(0)
        except Exception as e:
            logger.exception("Unhandled error: %s", e)
            sys.exit(1)

if __name__ == "__main__":
    main()

from __future__ import annotations
from pathlib import Path
from typing import Literal, cast
from a_core.configs.config import get_config
from b_infrastructure.database.manager import DatabaseOrchestrator, DBConfig, RemoteDBParams
from b_infrastructure.repositories.hot.status_snapshot import StatusSnapshotRepository
from b_infrastructure.repositories.hot.input_snapshot import InputSnapshotRepository
from b_infrastructure.repositories.cold.status_history import StatusHistoryRepository
from b_infrastructure.repositories.cold.input_history import InputHistoryRepository
from b_infrastructure.repositories.cold.status_period import StatusPeriodRepository
from b_infrastructure.repositories.cold.input_period import InputPeriodRepository
from b_infrastructure.repositories.sync_meta import SyncMetaRepo
from d_application.services.full_service import FullLoaderService

def build_container() -> tuple[FullLoaderService, DatabaseOrchestrator]:
    cfg = get_config()
    auth_val = cast(Literal["sql"], "sql")
    remote = RemoteDBParams(
        host=cfg.mssql_host,
        port=cfg.mssql_port,
        database=cfg.mssql_db,
        user=cfg.mssql_user,
        password=cfg.mssql_password,
        auth=auth_val,
    )
    base_dir = Path(getattr(cfg, "base_dir", Path.cwd()))
    dbm = DatabaseOrchestrator(base_dir, remote, DBConfig())
    status_snapshots = StatusSnapshotRepository(dbm)
    input_snapshots = InputSnapshotRepository(dbm)
    status_history = StatusHistoryRepository(dbm)
    input_history = InputHistoryRepository(dbm)
    status_periods = StatusPeriodRepository(dbm)
    input_periods = InputPeriodRepository(dbm)
    meta_repo_status = SyncMetaRepo(dbm.cold.engine)
    meta_repo_input = SyncMetaRepo(dbm.cold.engine)
    full_service = FullLoaderService(
        db=dbm,
        status_snapshots=status_snapshots,
        status_history=status_history,
        status_periods=status_periods,
        input_snapshots=input_snapshots,
        input_history=input_history,
        input_periods=input_periods,
        status_meta=meta_repo_status,
        input_meta=meta_repo_input,
    )
    return full_service, dbm

